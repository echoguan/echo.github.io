---
title: 算法时间复杂度、空间复杂度以及稳定性
categories: 技术
date: 2019-05-17 18:18:55
tags: [算法, 时间复杂度, 空间复杂度, 稳定性]
---

### 算法

- 算法（Algorithm）是指用来操作数据，解决程序问题的一组方法。
- 对于同一种问题，使用不同的算法，也许得到的结果是一样的，但在过程中消耗的时间和资源却可能天差地别。
- 所以怎么去衡量不同算法之间的优劣呢？我们主要从 **时间** 和 **空间** 两个维度来考量。
  - **时间复杂度：执行当前算法所消耗的时间。** 
  - **空间复杂度：执行当前算法需要占用的内存空间。** 
  - 对于一个算法，时间复杂度和空间复杂度往往是相互影响、相互制约的。往往是 **此消彼长** 的关系，鱼和熊掌不可兼得。
    - 所以当设计一个算法时，特别是大型算法，要综合考虑算法的各项性能，结合具体的使用场景，比如使用频率、数据量的大小、算法语言的特性以及机器环境等等各方面的因素，来设计出一个最优算法。

### 时间复杂度

#### 大O符号表示法

表示时间复杂度的通用方法是 **大O符号表示法** 。

- `T(n)` 表示 **时间频度** ，是指 **一个算法中语句执行次数。** 
- 当 n 不断变化时，T(n) 也会随之不断变化。为了了解这个变化的规律，便引入了 **时间复杂度** 这一概念。
- 如果有某个辅助函数 `f(n)` ，当 n 趋于无穷大时，`T(n)/f(n)` 的极限值是某个不为零的常数。那么 `f(n)` 是`T(n)` 的同数量级函数，记作 `T(n) = O(f(n))` ，被称为算法的渐进时间复杂度，简称为时间复杂度。
- `T(n) = O(f(n))` ，表示随着输入 n 的增大，算法执行所需时间的增长速度可以用 `f(n)` 表示。
- 大O符号表示法，表示的是**代码执行时间的增长变化趋势。** 

#### 如何计算执行次数 `T(n)` 呢？下面是四个简单的法则：

<!--more-->

- 对于**一个循环** ，假设循环体的时间复杂度是`O(m)` ，循环次数为`n` ，则时间复杂度是`O(n*m)` 。

  ```java
  for(int i = 0; i < n; i++) {         		// 循环次数为 n
      System.out.println("Hello, World!");    // 循环体时间复杂度为 O(1)
  }
  // 此时时间复杂度为 O(n*1)，即O(n)
  ```

- 对于**多个循环** ，分析时应该由里向外分析。

  ```java
  for(int i = 0; i < n; i++) {         // 循环次数为 n
      for(int j = 0; j < n; j++) {       // 循环次数为 n
          System.out.println("Hello, World!");      // 循环体时间复杂度为 O(1)
      }
  }
  // 时间复杂度为 O(n*n*1)，即O(n^2)
  ```

- 对于**顺序执行** 的语句，**总的时间复杂度等于其中最大的时间复杂度。** 

  ```java
  // 第一部分时间复杂度为 O(n^2)
  for(int i = 0; i < n; i++) {
      for(int j = 0; j < n; j++) {
          System.out.println("Hello, World!");
      }
  }
  // 第二部分时间复杂度为 O(n)
  for(int j = 0; j < n; j++) {
      System.out.println("Hello, World!");
  }
  
  // 总的时间复杂度为：max(O(n^2), O(n))，即O(n^2)
  ```

- 对于**条件判断** 的语句，**总的时间复杂度等于其中时间复杂度最大的路径的时间复杂度。** 

  ```java
  if (n >= 0) {
      // 第一条路径时间复杂度为 O(n^2)
      for(int i = 0; i < n; i++) {
          for(int j = 0; j < n; j++) {
              System.out.println("输入数据大于等于零");
          }
      }
  } else {
      // 第二条路径时间复杂度为 O(n)
      for(int j = 0; j < n; j++) {
          System.out.println("输入数据小于零");
      }
  }
  
  // 总的时间复杂度为：max(O(n^2), O(n))，即O(n^2)
  ```

- 总而言之，基本策略是：从内向外分析，从最深层开始分析，如果遇到函数调用，则要进入函数进行分析。

#### 那么当我们拿到 **算法的执行次数函数 T(n)**  之后，怎么得到 **算法的时间复杂度** 呢？

- **常数项对函数的增长速度影响并不大。** 
  - 当 `T(n) = c` 时，c 为一个常数，那么这个算法的时间复杂度**O(1)** 。
  - 如果`T(n)` 不等于一个常数项时，直接将**常数项忽略** 即可。比如 `T(n) = n + 29` ，则时间复杂度为**O(n)** 。
- **高次项对函数的增长速度影响是最大的，所以直接忽略低次项，只保留最高阶项。** 
  -  `n^3` 的增长速度是远超 `n^2` 的，`n^3 > n^2 > n` 。
  - 比如`T(n) = n^3 + n^2 + 29`，时间复杂度为**O(n^3)** 。
- **因为函数的阶数对函数的增长速度影响最大，所以直接忽略与最高阶相乘的常数。** 
  - 比如`T(n) = 3n^3`，时间复杂度为**O(n^3)** 。

#### 常见的时间复杂度量级：

- 常数阶：O(1)
- 对数阶：O(logN)
- 线性阶：O(n)
- 线性对数阶：O(nlogN)
- 平方阶：O(n^2)
- 立方阶：O(n^3)
- K次方阶：O(n^k)
- 指数阶：O(2^n)

**上面从上至下时间复杂度越来越大。** 执行效率越来越低。

![iterm2](/images/Big-O-Complexity-Chart.png)  

### 空间复杂度 

空间复杂度是指运行完一个程序所需内存的大小的一个度量。反映的是一个趋势。

程序执行所需内存空间包括两个部分：

- 固定部分：这部分 **空间的大小与输入输出数据的个数多少以及数值无关。** 主要包括指令空间（即代码空间）、数据空间（常量、简单变量）所占的空间。属于静态空间。

- 可变空间：这部分空间的大小主要包括动态分配的空间，以及递归栈所需的空间等。

#### 常见的空间复杂度

- O(1)

  - 如果算法执行所需的空间不随着变量n的大小而变化，即为一个常量。可表示为O(1)。

    ```java
    int i = 1;
    int j = 2;
    ++i;
    j++;
    int m = i + j;
    ```

    

- O(n)

  ```java
  int[] m = new int[n]
  for(i=1; i<=n; ++i)
  {
     j = i;
     j++;
  }
  ```

  - 这段代码中，第一行 new 了一个数组，数据占用的大小为 n。
  - 而第2-6行，虽然有循环，但是没有分配新的空间，所以可以忽略。
  - 即：S(n)=O(n)。

### 稳定性

#### 稳定性定义

- 稳定性就是指，能保证排序前后两个 **相等的数** 的 **相对位置** 不变。

- 比如：a = b，a 原先的位置在前面，则排序后 a 还是在b前面。

#### 稳定性的好处

- 从一个键上排序，然后从另一个键上排序，第一个键的结果可以为第二个键排序所用。
- 稳定性的意义更多是在于，除了相同的属性，剩下的那些不同的属性。



- 如果只是简单地进行数字的排序，那么稳定性没有什么意义。
- 如果排序的内容是一个复杂对象的多个属性，且其原本的初始顺序存在意义，那么就需要使用稳定性的算法。
- 例如：有一个以随机顺序排列的名字和姓氏的表格。如果按名字排序，然后按姓氏排序，则稳定排序算法将确保姓氏相同的用户按名字排序。

#### 常见算法的稳定性

- 稳定：冒泡排序、基数排序、直接插入排序、折半插入排序、归并排序
- 不稳定：快速排序、堆排序、希尔排序、直接选择排序



- 如果每次变换，都只是 **交换相邻的两个元素** ，那么就是稳定的。
- 如果每次都有某个元素 **和比较远的元素的交换** 操作，那么就是不稳定的。



> REFERENCES
>
> - [程序员吴师兄 - 冰与火之歌：「时间」与「空间」复杂度](<https://juejin.im/post/5c174198f265da611036f4ea#heading-18>) 
> - [raymondCaptain - （数据结构）十分钟搞定时间复杂度（算法的时间复杂度）](<https://www.jianshu.com/p/f4cca5ce055a>) 
> - [算法的时间复杂度和空间复杂度](https://juejin.im/entry/5a49f7d36fb9a0450a67b269) 
> - [算法的时间与空间复杂度（一看就懂）](<https://zhuanlan.zhihu.com/p/50479555>) 
> - [Zebul博 - 排序算法的稳定性及其意义](<https://blog.csdn.net/u012501054/article/details/79342580>)  