---
title: 时间复杂度与空间复杂度
categories: 技术
date: 2019-05-17 18:18:55
tags: [算法, 时间复杂度, 空间复杂度]
---

### 算法

- 算法（Algorithm）是指用来操作数据，解决程序问题的一组方法。
- 对于同一种问题，使用不同的算法，也许得到的结果是一样的，但在过程中消耗的时间和资源却可能天差地别。
- 所以怎么去衡量不同算法之间的优劣呢？我们主要从 **时间** 和 **空间** 两个维度来考量。
  - **时间复杂度：执行当前算法所消耗的时间。** 
  - **空间复杂度：执行当前算法需要占用的内存空间。** 
  - 对于一个算法，时间复杂度和空间复杂度往往是相互影响、相互制约的。往往是 **此消彼长** 的关系，鱼和熊掌不可兼得。
    - 所以当设计一个算法时，特别是大型算法，要综合考虑算法的各项性能，结合具体的使用场景，比如使用频率、数据量的大小、算法语言的特性以及机器环境等等各方面的因素，来设计出一个最优算法。

### 时间复杂度

#### 大O符号表示法

表示时间复杂度的通用方法是 **大O符号表示法** 。

- `T(n)` 表示 **时间频度** ，是指 **一个算法中语句执行次数。** 
- 当 n 不断变化时，T(n) 也会随之不断变化。为了了解这个变化的规律，便引入了 **时间复杂度** 这一概念。
- 如果有某个辅助函数 `f(n)` ，当 n 趋于无穷大时，`T(n)/f(n)` 的极限值是某个不为零的常数。那么 `f(n)` 是`T(n)` 的同数量级函数，记作 `T(n) = O(f(n))` ，被称为算法的渐进时间复杂度，简称为时间复杂度。
- `T(n) = O(f(n))` ，表示随着输入 n 的增大，算法执行所需时间的增长速度可以用 `f(n)` 表示。
- 大O符号表示法，表示的是**代码执行时间的增长变化趋势。** 

#### 如何计算执行次数 `T(n)` 呢？下面是四个简单的法则：

<!--more-->

- 对于**一个循环** ，假设循环体的时间复杂度是`O(m)` ，循环次数为`n` ，则时间复杂度是`O(n*m)` 。

  ```java
  for(int i = 0; i < n; i++) {         		// 循环次数为 n
      System.out.println("Hello, World!");    // 循环体时间复杂度为 O(1)
  }
  // 此时时间复杂度为 O(n*1)，即O(n)
  ```

- 对于**多个循环** ，分析时应该由里向外分析。

  ```java
  for(int i = 0; i < n; i++) {         // 循环次数为 n
      for(int j = 0; j < n; j++) {       // 循环次数为 n
          System.out.println("Hello, World!");      // 循环体时间复杂度为 O(1)
      }
  }
  // 时间复杂度为 O(n*n*1)，即O(n^2)
  ```

- 对于**顺序执行** 的语句，**总的时间复杂度等于其中最大的时间复杂度。** 

  ```java
  // 第一部分时间复杂度为 O(n^2)
  for(int i = 0; i < n; i++) {
      for(int j = 0; j < n; j++) {
          System.out.println("Hello, World!");
      }
  }
  // 第二部分时间复杂度为 O(n)
  for(int j = 0; j < n; j++) {
      System.out.println("Hello, World!");
  }
  
  // 总的时间复杂度为：max(O(n^2), O(n))，即O(n^2)
  ```

- 对于**条件判断** 的语句，**总的时间复杂度等于其中时间复杂度最大的路径的时间复杂度。** 

  ```java
  if (n >= 0) {
      // 第一条路径时间复杂度为 O(n^2)
      for(int i = 0; i < n; i++) {
          for(int j = 0; j < n; j++) {
              System.out.println("输入数据大于等于零");
          }
      }
  } else {
      // 第二条路径时间复杂度为 O(n)
      for(int j = 0; j < n; j++) {
          System.out.println("输入数据小于零");
      }
  }
  
  // 总的时间复杂度为：max(O(n^2), O(n))，即O(n^2)
  ```

- 总而言之，基本策略是：从内向外分析，从最深层开始分析，如果遇到函数调用，则要进入函数进行分析。

#### 那么当我们拿到 **算法的执行次数函数 T(n)**  之后，怎么得到 **算法的时间复杂度** 呢？

- **常数项对函数的增长速度影响并不大。** 
  - 当 `T(n) = c` 时，c 为一个常数，那么这个算法的时间复杂度**O(1)** 。
  - 如果`T(n)` 不等于一个常数项时，直接将**常数项忽略** 即可。比如 `T(n) = n + 29` ，则时间复杂度为**O(n)** 。
- **高次项对函数的增长速度影响是最大的，所以直接忽略低次项，只保留最高阶项。** 
  -  `n^3` 的增长速度是远超 `n^2` 的，`n^3 > n^2 > n` 。
  - 比如`T(n) = n^3 + n^2 + 29`，时间复杂度为**O(n^3)** 。
- **因为函数的阶数对函数的增长速度影响最大，所以直接忽略与最高阶相乘的常数。** 
  - 比如`T(n) = 3n^3`，时间复杂度为**O(n^3)** 。

#### 常见的时间复杂度量级：

- 常数阶：O(1)
- 对数阶：O(logN)
- 线性阶：O(n)
- 线性对数阶：O(nlogN)
- 平方阶：O(n^2)
- 立方阶：O(n^3)
- K次方阶：O(n^k)
- 指数阶：O(2^n)

**上面从上至下时间复杂度越来越大。** 执行效率越来越低。

![iterm2](/images/Big-O-Complexity-Chart.png) 