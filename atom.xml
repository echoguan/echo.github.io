<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>echo</title>
  
  <subtitle>十年大计，日拱一卒</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://echoguan.coding.me/"/>
  <updated>2019-08-07T05:53:51.875Z</updated>
  <id>http://echoguan.coding.me/</id>
  
  <author>
    <name>Echo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS !! 两个感叹号操作符</title>
    <link href="http://echoguan.coding.me/2019/08/07/JS-!!-%E4%B8%A4%E4%B8%AA%E6%84%9F%E5%8F%B9%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://echoguan.coding.me/2019/08/07/JS-!!-两个感叹号操作符/</id>
    <published>2019-08-07T05:42:56.000Z</published>
    <updated>2019-08-07T05:53:51.875Z</updated>
    
    <content type="html"><![CDATA[<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>把一个元素转换为<strong>其对应真正的布尔值</strong> ，一般用来判断某个元素是否存在。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base:</span></span><br><span class="line">!<span class="literal">true</span> = <span class="literal">false</span>;</span><br><span class="line">!!<span class="literal">true</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// extend:</span></span><br><span class="line">  </span><br><span class="line">!!<span class="string">"0"</span> = <span class="literal">true</span>;</span><br><span class="line">!!<span class="number">1</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">!!<span class="number">0</span> = <span class="literal">false</span>; </span><br><span class="line">!!<span class="string">""</span> = <span class="literal">false</span>; </span><br><span class="line">!!<span class="literal">undefined</span> = <span class="literal">false</span>;   </span><br><span class="line">!!<span class="literal">null</span> = <span class="literal">false</span>; </span><br><span class="line"><span class="keyword">var</span> a;  !!a = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;把一个元素转换为&lt;strong&gt;其对应真正的布尔值&lt;/strong&gt; ，一般用来判断某个元素是否存在。&lt;/li&gt;
&lt;/ul&gt;
&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://echoguan.coding.me/tags/Java/"/>
    
      <category term="Serialization" scheme="http://echoguan.coding.me/tags/Serialization/"/>
    
      <category term="序列化" scheme="http://echoguan.coding.me/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>常见英语词汇备忘</title>
    <link href="http://echoguan.coding.me/2019/06/28/English-Words-Memo/"/>
    <id>http://echoguan.coding.me/2019/06/28/English-Words-Memo/</id>
    <published>2019-06-28T06:38:25.000Z</published>
    <updated>2019-09-02T02:18:55.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="标点、英语符号"><a href="#标点、英语符号" class="headerlink" title="标点、英语符号"></a>标点、英语符号</h3><table><thead><tr><th>单词</th><th>词性</th><th>意思</th><th>示例和使用场景</th><th>发音（美）</th></tr></thead><tbody><tr><td>exclamation</td><td>n</td><td>！感叹、惊叹号</td><td></td><td>/ˌɛkskləˈmeʃən/</td></tr><tr><td>colon</td><td>n</td><td>：冒号</td><td></td><td>/‘kolən/</td></tr><tr><td>backticks</td><td>n</td><td>` 倒引号</td><td></td><td>/bæk/ /tɪk/</td></tr><tr><td>underscore</td><td>v/n</td><td>_ 下划线</td><td></td><td>[,ʌndɚ’skɔr]</td></tr><tr><td>semicolon</td><td>n</td><td>; 分号</td><td></td><td>[‘sɛmɪkolən]</td></tr><tr><td>comma</td><td>n</td><td>, 逗号</td><td></td><td>[‘kɑmə]</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;标点、英语符号&quot;&gt;&lt;a href=&quot;#标点、英语符号&quot; class=&quot;headerlink&quot; title=&quot;标点、英语符号&quot;&gt;&lt;/a&gt;标点、英语符号&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;单词&lt;/th&gt;
&lt;th&gt;词性&lt;/th&gt;
&lt;th&gt;意思&lt;/
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="English" scheme="http://echoguan.coding.me/tags/English/"/>
    
      <category term="英语" scheme="http://echoguan.coding.me/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="单词" scheme="http://echoguan.coding.me/tags/%E5%8D%95%E8%AF%8D/"/>
    
      <category term="备忘" scheme="http://echoguan.coding.me/tags/%E5%A4%87%E5%BF%98/"/>
    
  </entry>
  
  <entry>
    <title>Java 序列化</title>
    <link href="http://echoguan.coding.me/2019/05/27/Java-Serialization/"/>
    <id>http://echoguan.coding.me/2019/05/27/Java-Serialization/</id>
    <published>2019-05-27T07:07:47.000Z</published>
    <updated>2019-05-31T09:08:34.717Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>序列化是一种 <strong>对象</strong> 持久化的手段。普遍应用在网络传输、RMI（远程方法调用）等场景中。</p></blockquote><p>本篇主要会涉及以下几个方面：</p><blockquote><ul><li>序列化与反序列化</li><li>Java 对象的序列化与反序列化<ul><li>用途</li><li>示例代码</li></ul></li><li>相关接口与类</li><li><code>Transient</code> 关键字</li><li>序列化 ID <code>SerialVersionUID</code> </li></ul></blockquote><h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><ul><li>序列化（Serialization）是指，将 <strong>对象的状态信息</strong> 转化为 <strong>可以存储或传输的形式</strong> 的过程。</li><li>与上述相反的过程称为反序列化。</li></ul><h3 id="Java-对象的序列化与反序列化"><a href="#Java-对象的序列化与反序列化" class="headerlink" title="Java 对象的序列化与反序列化"></a>Java 对象的序列化与反序列化</h3><ul><li>Java 平台允许我们在内存中创建可以复用的 Java 对象，但一般情况下，只有当 JVM 处于运行状态时，这些对象才存在。</li><li>而在实际应用中，就可能要求在 JVM 停止运行之后仍然能够保存（持久化）指定的对象，并在将来重新读取被保存的对象。</li><li>Java 的对象序列化就是为了方便我们实现该功能。</li></ul><h4 id="序列化的用途"><a href="#序列化的用途" class="headerlink" title="序列化的用途"></a>序列化的用途</h4><ul><li>想把内存中的 <strong>对象状态</strong> ，保存到一个 <strong>文件或者数据库</strong> 中的时候。</li><li>想把对象 <strong>通过网络进行传播</strong> 的时候。</li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>如何对 Java 对象进行序列化和反序列化？</p><ul><li>在 Java 中只要一个类实现了 <code>java.io.Serializable</code> 接口，那么它就可以被序列化。（[该接口并没有方法和字段，为什么只有实现了该接口的类的对象才能被序列化呢？](<a href="http://www.hollischuang.com/archives/1140#What" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1140#What</a> Serializable Did)）</li><li>当试图对一个对象进行序列化时，如果遇到了没有实现 Serializable 接口的对象。就会抛出 <code>NotSerializableException</code> 异常。</li><li>如果要序列化的对象的类有父类，并且想要同时将在父类中定义过的变量持久化下来。那么父类也要实现 <code>java.io.Serializable</code> 接口。</li></ul><h3 id="相关接口与类"><a href="#相关接口与类" class="headerlink" title="相关接口与类"></a>相关接口与类</h3><ul><li><code>java.io.Serializable</code> </li><li><code>java.io.Externalizable</code> </li><li><code>ObjectOutput</code> </li><li><code>ObjectInput</code> </li><li><code>ObjectOutputStream</code> </li><li><code>ObjectInputStream</code> </li></ul><blockquote><p>WIP</p><p><a href="https://www.hollischuang.com/archives/1140" target="_blank" rel="noopener">https://www.hollischuang.com/archives/1140</a></p><p><a href="https://www.hollischuang.com/archives/1150" target="_blank" rel="noopener">https://www.hollischuang.com/archives/1150</a></p><p><a href="https://www.hollischuang.com/archives/1144" target="_blank" rel="noopener">https://www.hollischuang.com/archives/1144</a></p><p><a href="http://www.hollischuang.com/archives/205" target="_blank" rel="noopener">http://www.hollischuang.com/archives/205</a></p><p><a href="http://blademastercoder.github.io/2015/01/29/java-Serializable.html" target="_blank" rel="noopener">http://blademastercoder.github.io/2015/01/29/java-Serializable.html</a></p><p><a href="https://www.runoob.com/java/java-serialization.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-serialization.html</a></p></blockquote><blockquote><p>REFERENCES</p><ul><li><a href="https://www.hollischuang.com/archives/1140" target="_blank" rel="noopener">hollis - 深入分析 Java 的序列化与反序列化</a> </li><li><a href="https://www.hollischuang.com/archives/1150" target="_blank" rel="noopener">hollis - Java 对象的序列化与反序列化</a> </li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;序列化是一种 &lt;strong&gt;对象&lt;/strong&gt; 持久化的手段。普遍应用在网络传输、RMI（远程方法调用）等场景中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇主要会涉及以下几个方面：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;序
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://echoguan.coding.me/tags/Java/"/>
    
      <category term="Serialization" scheme="http://echoguan.coding.me/tags/Serialization/"/>
    
      <category term="序列化" scheme="http://echoguan.coding.me/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>计数质数 - 厄拉多塞筛法</title>
    <link href="http://echoguan.coding.me/2019/05/24/Count-Primes-Sieve-of-Eeatosthese/"/>
    <id>http://echoguan.coding.me/2019/05/24/Count-Primes-Sieve-of-Eeatosthese/</id>
    <published>2019-05-24T05:47:01.000Z</published>
    <updated>2019-05-24T06:21:15.964Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目：204. 计数质数（统计所有小于非负整数 n 的质数的数量）</p></blockquote><p>质数：又称素数，指在大于 1 的自然数中，除了1和该数自身外，无法被其他自然数整除的数。</p><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><h4 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h4><ul><li>遍历数字 n 是否能被从 2 到 sqrt(n) 之间的质数整除。</li></ul><h4 id="代码（JAVA）"><a href="#代码（JAVA）" class="headerlink" title="代码（JAVA）"></a><a href="https://github.com/echoguan/LeetCode/blob/master/src/com/echo/easy/_204/CountPrimes.java" target="_blank" rel="noopener">代码（JAVA）</a></h4><h3 id="思路二：厄拉多塞筛法"><a href="#思路二：厄拉多塞筛法" class="headerlink" title="思路二：厄拉多塞筛法"></a>思路二：厄拉多塞筛法</h3><h4 id="具体思路-1"><a href="#具体思路-1" class="headerlink" title="具体思路"></a>具体思路</h4><ul><li>先将 <code>2-n</code> 的各个数字放入表中。</li><li>在 2 的上面画一个圆圈；然后划去其它所有 2 的倍数的数字。</li><li>接下来第一个未画圈又没有被划去的数字是 3，将它画圈；然后再划去 3 的倍数。</li><li>接下来第一个未画圈又没有被划去的数字是 5，将它画圈；然后再划去 5 的倍数。</li><li>…… 以此类推；直到所有小于或者等于 n 的数字都被画圈或者划掉为止。<ul><li>其实，当你要画圈的数字的平方大于 n 时，那么后面没有被划掉的数字都是质数，不需要继续往后判断了。</li></ul></li><li>这时表中所有画了圈和未被划去的数字就是小于等于 n 的质数。</li></ul><h4 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h4><p><img src="/images/Sieve_of_Eratosthenes_animation.gif" alt="iterm2">   </p><h4 id="代码（JAVA）-1"><a href="#代码（JAVA）-1" class="headerlink" title="代码（JAVA）"></a><a href="https://github.com/echoguan/LeetCode/blob/master/src/com/echo/easy/_204/CountPrimesEeatosthese.java" target="_blank" rel="noopener">代码（JAVA）</a></h4><h3 id="思路比较"><a href="#思路比较" class="headerlink" title="思路比较"></a>思路比较</h3><ul><li>思路一比较容易想到，但思路二效率会高很多。</li></ul><blockquote><p>REFERENCES</p><ul><li><a href="https://blog.csdn.net/u013291076/article/details/45575967" target="_blank" rel="noopener">__Daniel - 厄拉多塞筛法</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;题目：204. 计数质数（统计所有小于非负整数 n 的质数的数量）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;质数：又称素数，指在大于 1 的自然数中，除了1和该数自身外，无法被其他自然数整除的数。&lt;/p&gt;
&lt;h3 id=&quot;思路一&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="算法" scheme="http://echoguan.coding.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://echoguan.coding.me/tags/LeetCode/"/>
    
      <category term="Primes" scheme="http://echoguan.coding.me/tags/Primes/"/>
    
  </entry>
  
  <entry>
    <title>算法时间复杂度、空间复杂度以及稳定性</title>
    <link href="http://echoguan.coding.me/2019/05/17/Time-Space-complexity/"/>
    <id>http://echoguan.coding.me/2019/05/17/Time-Space-complexity/</id>
    <published>2019-05-17T10:18:55.000Z</published>
    <updated>2019-05-23T05:51:32.138Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul><li>算法（Algorithm）是指用来操作数据，解决程序问题的一组方法。</li><li>对于同一种问题，使用不同的算法，也许得到的结果是一样的，但在过程中消耗的时间和资源却可能天差地别。</li><li>所以怎么去衡量不同算法之间的优劣呢？我们主要从 <strong>时间</strong> 和 <strong>空间</strong> 两个维度来考量。<ul><li><strong>时间复杂度：执行当前算法所消耗的时间。</strong> </li><li><strong>空间复杂度：执行当前算法需要占用的内存空间。</strong> </li><li>对于一个算法，时间复杂度和空间复杂度往往是相互影响、相互制约的。往往是 <strong>此消彼长</strong> 的关系，鱼和熊掌不可兼得。<ul><li>所以当设计一个算法时，特别是大型算法，要综合考虑算法的各项性能，结合具体的使用场景，比如使用频率、数据量的大小、算法语言的特性以及机器环境等等各方面的因素，来设计出一个最优算法。</li></ul></li></ul></li></ul><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><h4 id="大O符号表示法"><a href="#大O符号表示法" class="headerlink" title="大O符号表示法"></a>大O符号表示法</h4><p>表示时间复杂度的通用方法是 <strong>大O符号表示法</strong> 。</p><ul><li><code>T(n)</code> 表示 <strong>时间频度</strong> ，是指 <strong>一个算法中语句执行次数。</strong> </li><li>当 n 不断变化时，T(n) 也会随之不断变化。为了了解这个变化的规律，便引入了 <strong>时间复杂度</strong> 这一概念。</li><li>如果有某个辅助函数 <code>f(n)</code> ，当 n 趋于无穷大时，<code>T(n)/f(n)</code> 的极限值是某个不为零的常数。那么 <code>f(n)</code> 是<code>T(n)</code> 的同数量级函数，记作 <code>T(n) = O(f(n))</code> ，被称为算法的渐进时间复杂度，简称为时间复杂度。</li><li><code>T(n) = O(f(n))</code> ，表示随着输入 n 的增大，算法执行所需时间的增长速度可以用 <code>f(n)</code> 表示。</li><li>大O符号表示法，表示的是<strong>代码执行时间的增长变化趋势。</strong> </li></ul><h4 id="如何计算执行次数-T-n-呢？下面是四个简单的法则："><a href="#如何计算执行次数-T-n-呢？下面是四个简单的法则：" class="headerlink" title="如何计算执行次数 T(n) 呢？下面是四个简单的法则："></a>如何计算执行次数 <code>T(n)</code> 呢？下面是四个简单的法则：</h4><a id="more"></a><ul><li><p>对于<strong>一个循环</strong> ，假设循环体的时间复杂度是<code>O(m)</code> ，循环次数为<code>n</code> ，则时间复杂度是<code>O(n*m)</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;         <span class="comment">// 循环次数为 n</span></span><br><span class="line">    System.out.println(<span class="string">"Hello, World!"</span>);    <span class="comment">// 循环体时间复杂度为 O(1)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时时间复杂度为 O(n*1)，即O(n)</span></span><br></pre></td></tr></table></figure></li><li><p>对于<strong>多个循环</strong> ，分析时应该由里向外分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;         <span class="comment">// 循环次数为 n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;       <span class="comment">// 循环次数为 n</span></span><br><span class="line">        System.out.println(<span class="string">"Hello, World!"</span>);      <span class="comment">// 循环体时间复杂度为 O(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 时间复杂度为 O(n*n*1)，即O(n^2)</span></span><br></pre></td></tr></table></figure></li><li><p>对于<strong>顺序执行</strong> 的语句，<strong>总的时间复杂度等于其中最大的时间复杂度。</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一部分时间复杂度为 O(n^2)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二部分时间复杂度为 O(n)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello, World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总的时间复杂度为：max(O(n^2), O(n))，即O(n^2)</span></span><br></pre></td></tr></table></figure></li><li><p>对于<strong>条件判断</strong> 的语句，<strong>总的时间复杂度等于其中时间复杂度最大的路径的时间复杂度。</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 第一条路径时间复杂度为 O(n^2)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"输入数据大于等于零"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 第二条路径时间复杂度为 O(n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"输入数据小于零"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总的时间复杂度为：max(O(n^2), O(n))，即O(n^2)</span></span><br></pre></td></tr></table></figure></li><li><p>总而言之，基本策略是：从内向外分析，从最深层开始分析，如果遇到函数调用，则要进入函数进行分析。</p></li></ul><h4 id="那么当我们拿到-算法的执行次数函数-T-n-之后，怎么得到-算法的时间复杂度-呢？"><a href="#那么当我们拿到-算法的执行次数函数-T-n-之后，怎么得到-算法的时间复杂度-呢？" class="headerlink" title="那么当我们拿到 算法的执行次数函数 T(n)  之后，怎么得到 算法的时间复杂度 呢？"></a>那么当我们拿到 <strong>算法的执行次数函数 T(n)</strong>  之后，怎么得到 <strong>算法的时间复杂度</strong> 呢？</h4><ul><li><strong>常数项对函数的增长速度影响并不大。</strong> <ul><li>当 <code>T(n) = c</code> 时，c 为一个常数，那么这个算法的时间复杂度<strong>O(1)</strong> 。</li><li>如果<code>T(n)</code> 不等于一个常数项时，直接将<strong>常数项忽略</strong> 即可。比如 <code>T(n) = n + 29</code> ，则时间复杂度为<strong>O(n)</strong> 。</li></ul></li><li><strong>高次项对函数的增长速度影响是最大的，所以直接忽略低次项，只保留最高阶项。</strong> <ul><li><code>n^3</code> 的增长速度是远超 <code>n^2</code> 的，<code>n^3 &gt; n^2 &gt; n</code> 。</li><li>比如<code>T(n) = n^3 + n^2 + 29</code>，时间复杂度为<strong>O(n^3)</strong> 。</li></ul></li><li><strong>因为函数的阶数对函数的增长速度影响最大，所以直接忽略与最高阶相乘的常数。</strong> <ul><li>比如<code>T(n) = 3n^3</code>，时间复杂度为<strong>O(n^3)</strong> 。</li></ul></li></ul><h4 id="常见的时间复杂度量级："><a href="#常见的时间复杂度量级：" class="headerlink" title="常见的时间复杂度量级："></a>常见的时间复杂度量级：</h4><ul><li>常数阶：O(1)</li><li>对数阶：O(logN)</li><li>线性阶：O(n)</li><li>线性对数阶：O(nlogN)</li><li>平方阶：O(n^2)</li><li>立方阶：O(n^3)</li><li>K次方阶：O(n^k)</li><li>指数阶：O(2^n)</li></ul><p><strong>上面从上至下时间复杂度越来越大。</strong> 执行效率越来越低。</p><p><img src="/images/Big-O-Complexity-Chart.png" alt="iterm2">  </p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>空间复杂度是指运行完一个程序所需内存的大小的一个度量。反映的是一个趋势。</p><p>程序执行所需内存空间包括两个部分：</p><ul><li><p>固定部分：这部分 <strong>空间的大小与输入输出数据的个数多少以及数值无关。</strong> 主要包括指令空间（即代码空间）、数据空间（常量、简单变量）所占的空间。属于静态空间。</p></li><li><p>可变空间：这部分空间的大小主要包括动态分配的空间，以及递归栈所需的空间等。</p></li></ul><h4 id="常见的空间复杂度"><a href="#常见的空间复杂度" class="headerlink" title="常见的空间复杂度"></a>常见的空间复杂度</h4><ul><li><p>O(1)</p><ul><li><p>如果算法执行所需的空间不随着变量n的大小而变化，即为一个常量。可表示为O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">int</span> m = i + j;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] m = <span class="keyword">new</span> <span class="keyword">int</span>[n]</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这段代码中，第一行 new 了一个数组，数据占用的大小为 n。</li><li>而第2-6行，虽然有循环，但是没有分配新的空间，所以可以忽略。</li><li>即：S(n)=O(n)。</li></ul></li></ul><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><h4 id="稳定性定义"><a href="#稳定性定义" class="headerlink" title="稳定性定义"></a>稳定性定义</h4><ul><li><p>稳定性就是指，能保证排序前后两个 <strong>相等的数</strong> 的 <strong>相对位置</strong> 不变。</p></li><li><p>比如：a = b，a 原先的位置在前面，则排序后 a 还是在b前面。</p></li></ul><h4 id="稳定性的好处"><a href="#稳定性的好处" class="headerlink" title="稳定性的好处"></a>稳定性的好处</h4><ul><li>从一个键上排序，然后从另一个键上排序，第一个键的结果可以为第二个键排序所用。</li><li>稳定性的意义更多是在于，除了相同的属性，剩下的那些不同的属性。</li></ul><ul><li>如果只是简单地进行数字的排序，那么稳定性没有什么意义。</li><li>如果排序的内容是一个复杂对象的多个属性，且其原本的初始顺序存在意义，那么就需要使用稳定性的算法。</li><li>例如：有一个以随机顺序排列的名字和姓氏的表格。如果按名字排序，然后按姓氏排序，则稳定排序算法将确保姓氏相同的用户按名字排序。</li></ul><h4 id="常见算法的稳定性"><a href="#常见算法的稳定性" class="headerlink" title="常见算法的稳定性"></a>常见算法的稳定性</h4><ul><li>稳定：冒泡排序、基数排序、直接插入排序、折半插入排序、归并排序</li><li>不稳定：快速排序、堆排序、希尔排序、直接选择排序</li></ul><ul><li>如果每次变换，都只是 <strong>交换相邻的两个元素</strong> ，那么就是稳定的。</li><li>如果每次都有某个元素 <strong>和比较远的元素的交换</strong> 操作，那么就是不稳定的。</li></ul><blockquote><p>REFERENCES</p><ul><li><a href="https://juejin.im/post/5c174198f265da611036f4ea#heading-18" target="_blank" rel="noopener">程序员吴师兄 - 冰与火之歌：「时间」与「空间」复杂度</a> </li><li><a href="https://www.jianshu.com/p/f4cca5ce055a" target="_blank" rel="noopener">raymondCaptain - （数据结构）十分钟搞定时间复杂度（算法的时间复杂度）</a> </li><li><a href="https://juejin.im/entry/5a49f7d36fb9a0450a67b269" target="_blank" rel="noopener">算法的时间复杂度和空间复杂度</a> </li><li><a href="https://zhuanlan.zhihu.com/p/50479555" target="_blank" rel="noopener">算法的时间与空间复杂度（一看就懂）</a> </li><li><a href="https://blog.csdn.net/u012501054/article/details/79342580" target="_blank" rel="noopener">Zebul博 - 排序算法的稳定性及其意义</a>  </li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;算法（Algorithm）是指用来操作数据，解决程序问题的一组方法。&lt;/li&gt;
&lt;li&gt;对于同一种问题，使用不同的算法，也许得到的结果是一样的，但在过程中消耗的时间和资源却可能天差地别。&lt;/li&gt;
&lt;li&gt;所以怎么去衡量不同算法之间的优劣呢？我们主要从 &lt;strong&gt;时间&lt;/strong&gt; 和 &lt;strong&gt;空间&lt;/strong&gt; 两个维度来考量。&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;时间复杂度：执行当前算法所消耗的时间。&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空间复杂度：执行当前算法需要占用的内存空间。&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;对于一个算法，时间复杂度和空间复杂度往往是相互影响、相互制约的。往往是 &lt;strong&gt;此消彼长&lt;/strong&gt; 的关系，鱼和熊掌不可兼得。&lt;ul&gt;
&lt;li&gt;所以当设计一个算法时，特别是大型算法，要综合考虑算法的各项性能，结合具体的使用场景，比如使用频率、数据量的大小、算法语言的特性以及机器环境等等各方面的因素，来设计出一个最优算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;&lt;/a&gt;时间复杂度&lt;/h3&gt;&lt;h4 id=&quot;大O符号表示法&quot;&gt;&lt;a href=&quot;#大O符号表示法&quot; class=&quot;headerlink&quot; title=&quot;大O符号表示法&quot;&gt;&lt;/a&gt;大O符号表示法&lt;/h4&gt;&lt;p&gt;表示时间复杂度的通用方法是 &lt;strong&gt;大O符号表示法&lt;/strong&gt; 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T(n)&lt;/code&gt; 表示 &lt;strong&gt;时间频度&lt;/strong&gt; ，是指 &lt;strong&gt;一个算法中语句执行次数。&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;当 n 不断变化时，T(n) 也会随之不断变化。为了了解这个变化的规律，便引入了 &lt;strong&gt;时间复杂度&lt;/strong&gt; 这一概念。&lt;/li&gt;
&lt;li&gt;如果有某个辅助函数 &lt;code&gt;f(n)&lt;/code&gt; ，当 n 趋于无穷大时，&lt;code&gt;T(n)/f(n)&lt;/code&gt; 的极限值是某个不为零的常数。那么 &lt;code&gt;f(n)&lt;/code&gt; 是&lt;code&gt;T(n)&lt;/code&gt; 的同数量级函数，记作 &lt;code&gt;T(n) = O(f(n))&lt;/code&gt; ，被称为算法的渐进时间复杂度，简称为时间复杂度。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;T(n) = O(f(n))&lt;/code&gt; ，表示随着输入 n 的增大，算法执行所需时间的增长速度可以用 &lt;code&gt;f(n)&lt;/code&gt; 表示。&lt;/li&gt;
&lt;li&gt;大O符号表示法，表示的是&lt;strong&gt;代码执行时间的增长变化趋势。&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;如何计算执行次数-T-n-呢？下面是四个简单的法则：&quot;&gt;&lt;a href=&quot;#如何计算执行次数-T-n-呢？下面是四个简单的法则：&quot; class=&quot;headerlink&quot; title=&quot;如何计算执行次数 T(n) 呢？下面是四个简单的法则：&quot;&gt;&lt;/a&gt;如何计算执行次数 &lt;code&gt;T(n)&lt;/code&gt; 呢？下面是四个简单的法则：&lt;/h4&gt;
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="算法" scheme="http://echoguan.coding.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="时间复杂度" scheme="http://echoguan.coding.me/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
      <category term="空间复杂度" scheme="http://echoguan.coding.me/tags/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
      <category term="稳定性" scheme="http://echoguan.coding.me/tags/%E7%A8%B3%E5%AE%9A%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序（Bubble Sort）</title>
    <link href="http://echoguan.coding.me/2019/05/17/Bubble-Sort/"/>
    <id>http://echoguan.coding.me/2019/05/17/Bubble-Sort/</id>
    <published>2019-05-17T03:01:46.000Z</published>
    <updated>2019-11-22T08:07:17.811Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法步骤（从小到大）"><a href="#算法步骤（从小到大）" class="headerlink" title="算法步骤（从小到大）"></a>算法步骤（从小到大）</h3><ul><li><p>比较相邻两个元素，如果前一个比后一个大，就交换它们。</p></li><li><p>从最后的元素开始，对每一对相邻元素做同样的工作，从最后一对到开头第一对。之后最前面的元素是最小的数。</p></li><li><p>重复上一步，除了已经排好的最小的数。</p></li></ul><h3 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="/images/Bubble-Sort.gif" alt="iterm2">  </p><p>动画出自 五分钟学算法 公众号，链接见最后引用。</p><h3 id="代码实现（JAVA）"><a href="#代码实现（JAVA）" class="headerlink" title="代码实现（JAVA）"></a><a href="https://github.com/echoguan/LeetCode/blob/master/src/com/echo/sort/BubbleSort.java" target="_blank" rel="noopener">代码实现（JAVA）</a></h3><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>Time complexity: O(n^2)</li><li>Space complexity: O(1)</li></ul><blockquote><p>REFERENCES</p><ul><li><a href="https://mp.weixin.qq.com/s/vn3KiV-ez79FmbZ36SX9lg" target="_blank" rel="noopener">五分钟学算法 - 十大经典排序算法动画与解析，看我就够了！（配代码完全版）</a> </li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;算法步骤（从小到大）&quot;&gt;&lt;a href=&quot;#算法步骤（从小到大）&quot; class=&quot;headerlink&quot; title=&quot;算法步骤（从小到大）&quot;&gt;&lt;/a&gt;算法步骤（从小到大）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;比较相邻两个元素，如果前一个比后一个大，就交换它们。&lt;/p
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="算法" scheme="http://echoguan.coding.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://echoguan.coding.me/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="冒泡" scheme="http://echoguan.coding.me/tags/%E5%86%92%E6%B3%A1/"/>
    
  </entry>
  
  <entry>
    <title>学习备忘 Tips</title>
    <link href="http://echoguan.coding.me/2019/04/22/MEMO-Tips/"/>
    <id>http://echoguan.coding.me/2019/04/22/MEMO-Tips/</id>
    <published>2019-04-22T00:47:29.000Z</published>
    <updated>2019-05-31T02:50:21.376Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Git-Rebase"><a href="#Git-Rebase" class="headerlink" title="Git Rebase"></a>Git Rebase</h4><blockquote><ul><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA" target="_blank" rel="noopener">3.6 Git 分支 - 变基</a> </li><li><a href="http://jartto.wang/2018/12/11/git-rebase/" target="_blank" rel="noopener">jartto - 彻底搞懂 Git-Rebase</a> </li></ul></blockquote><h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><ul><li>TLS - Transport Layer Security(传输层安全协议)<ul><li>其前身是SSL(Secure Sockets Layer, 安全套接层)</li><li>目的是为互联网通信提供安全及数据完整性保障。</li></ul></li></ul><h4 id="Node-js-ES6-CommonJS-Module-模块机制"><a href="#Node-js-ES6-CommonJS-Module-模块机制" class="headerlink" title="Node.js ES6/CommonJS Module 模块机制"></a>Node.js ES6/CommonJS Module 模块机制</h4><ul><li>exports 和 module.exports 的区别了：<ul><li>module.exports 初始值为一个空对象 {}</li><li>exports 是指向的 module.exports 的引用</li><li>require() 返回的是 module.exports 而不是 exports</li></ul></li></ul><ul><li><a href="https://www.jianshu.com/p/0bd1ae24152d" target="_blank" rel="noopener">CommonJS是什么？</a> </li><li><a href="https://cnodejs.org/topic/5a0f2da5f9de6bb0542f090b" target="_blank" rel="noopener">Node 9下import/export的丝般顺滑使用</a> </li><li><a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="noopener">CommonJS规范</a> </li><li><a href="http://es6.ruanyifeng.com/#docs/module-loader" target="_blank" rel="noopener">Module 的加载实现</a> </li></ul><h4 id="JavaScript：变量提升和函数提升"><a href="#JavaScript：变量提升和函数提升" class="headerlink" title="JavaScript：变量提升和函数提升"></a><a href="https://www.cnblogs.com/liuhe688/p/5891273.html" target="_blank" rel="noopener">JavaScript：变量提升和函数提升</a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Git-Rebase&quot;&gt;&lt;a href=&quot;#Git-Rebase&quot; class=&quot;headerlink&quot; title=&quot;Git Rebase&quot;&gt;&lt;/a&gt;Git Rebase&lt;/h4&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gi
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="备忘" scheme="http://echoguan.coding.me/tags/%E5%A4%87%E5%BF%98/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio 快捷键备忘</title>
    <link href="http://echoguan.coding.me/2018/11/29/Android-Studio-%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%87%E5%BF%98/"/>
    <id>http://echoguan.coding.me/2018/11/29/Android-Studio-快捷键备忘/</id>
    <published>2018-11-29T10:21:16.000Z</published>
    <updated>2018-12-03T03:21:58.006Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Esc</td><td>让编辑器窗口获取焦点，这时候就可以输入代码了</td></tr><tr><td>Shift + Esc</td><td>这个会让编辑器获取焦点，并且顺手帮你把刚刚打开的窗口关闭了。</td></tr><tr><td>shift + F6</td><td>重命名变量(refactor)</td></tr><tr><td>ctrl +左键点击方法名</td><td>Show usages of method</td></tr><tr><td>Ctrl + E</td><td>显示最近打开的文件记录列表</td></tr><tr><td>Ctrl + G</td><td>在当前文件跳转到指定行处</td></tr><tr><td>Ctrl + Q</td><td>光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td></tr><tr><td>Ctrl + Alt + L</td><td>格式化代码，可以对当前文件和整个包目录使用</td></tr><tr><td>Ctrl + Shift + U</td><td>对选中的代码进行大 / 小写轮流转换</td></tr><tr><td>Ctrl + Shift + T</td><td>对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择</td></tr><tr><td>F2</td><td>跳转到下一个高亮错误 或 警告位置</td></tr></tbody></table><blockquote><p><a href="https://my.oschina.net/quanke/blog/749038" target="_blank" rel="noopener">Android Studio 使用艺术 - 快捷键完整版</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;th&gt;介绍&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Esc&lt;/td&gt;
&lt;td&gt;让编辑器窗口获取焦点，这时候就可以输入代码了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shift +
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://echoguan.coding.me/tags/Android/"/>
    
      <category term="快捷键" scheme="http://echoguan.coding.me/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>Java - equals() 和 hashCode() 方法</title>
    <link href="http://echoguan.coding.me/2018/11/23/Java-equals%E5%92%8ChashCode%E6%96%B9%E6%B3%95/"/>
    <id>http://echoguan.coding.me/2018/11/23/Java-equals和hashCode方法/</id>
    <published>2018-11-23T06:53:22.000Z</published>
    <updated>2018-11-23T11:25:34.529Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote><h3 id="hashCode-和-equals-方法的作用？什么时候必须重写？"><a href="#hashCode-和-equals-方法的作用？什么时候必须重写？" class="headerlink" title="hashCode() 和 equals() 方法的作用？什么时候必须重写？"></a><code>hashCode()</code> 和 <code>equals()</code> 方法的作用？什么时候必须重写？</h3><ul><li><code>equals(Object obj)</code> 方法用来判断两个对象是否相等。<ul><li>Indicates whether some other object is “equal to” this one.</li></ul></li><li><code>hashCode()</code> 方法用来返回对象的哈希码。(哈希码作用是确定该对象在散列存储结构中的存储位置)<ul><li>Returns a hash code value for the object.</li></ul></li><li>这两个方法的规范：<ul><li>如果两个对象相同，<code>equals()</code> 方法一定返回<code>true</code> ，并且这两个对象的<code>hashCode()</code> 相同。</li><li>如果两个对象的<code>hashCode()</code> 相同，不代表两个对象就相同。只能说明这两个对象在散列存储结构中，存放在同一个位置。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;hashCode-和-equals-方法的作用？什么时候必须重写？&quot;&gt;&lt;a href=&quot;#hashCode-和-equals-方法的作用？什么时候必须重写？&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://echoguan.coding.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java - 集合Set(2) - Note</title>
    <link href="http://echoguan.coding.me/2018/11/23/Java-%E9%9B%86%E5%90%88Set-2/"/>
    <id>http://echoguan.coding.me/2018/11/23/Java-集合Set-2/</id>
    <published>2018-11-23T06:10:04.000Z</published>
    <updated>2019-05-21T02:29:06.160Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote><blockquote><p><code>Set</code>  <strong>不允许包含重复元素</strong> 。</p></blockquote><h3 id="HashSet-类"><a href="#HashSet-类" class="headerlink" title="HashSet 类"></a>HashSet 类</h3><ul><li><code>HashSet</code> 简介<ul><li><code>HashSet</code> 是<code>Set接口</code> 的典型实现。</li><li>实现了<code>Set接口</code> 中的所有方法，并没有添加额外的方法。</li><li><code>HashSet</code> 按 <code>Hash 算法</code> 来存储集合中的元素，因此<strong>具有很好的存取和查找性能</strong> 。</li></ul></li></ul><ul><li>特点<ul><li><strong>不能保证元素的排列顺序</strong> 。顺序可能与添加的顺序不同，顺序也可能发生变化。</li><li><strong>HashSet 不是同步的</strong> 。</li><li>集合元素可以是 <code>null</code> 。</li><li>判断两个元素是否相等的标准是：<ol><li>两个对象通过<code>equals()</code> 方法比较相等。</li><li>并且，两个对象的<code>hashCode()</code> 方法的返回值也相等。</li></ol></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Set&lt;/code&gt;  &lt;strong&gt;不允许包含重复元素&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;HashSet-类&quot;&gt;&lt;a href=&quot;#Has
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="集合" scheme="http://echoguan.coding.me/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java - 集合介绍(1) - Note</title>
    <link href="http://echoguan.coding.me/2018/11/13/Java-%E9%9B%86%E5%90%88%E4%BB%8B%E7%BB%8D-1/"/>
    <id>http://echoguan.coding.me/2018/11/13/Java-集合介绍-1/</id>
    <published>2018-11-13T06:59:05.000Z</published>
    <updated>2019-05-20T11:03:00.531Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.jianshu.com/p/589d58033841" target="_blank" rel="noopener">Ruheng - 由浅入深理解java集合(一)——集合框架 Collection、Map</a> </p></blockquote><h4 id="集合简介"><a href="#集合简介" class="headerlink" title="集合简介"></a>集合简介</h4><ul><li><strong>Java 集合</strong> 大致可分为<code>Set</code> , <code>List</code> , <code>Queue</code> , <code>Map</code> 四大体系。</li><li><strong>Set</strong> 代表 <strong>无序、不可重复</strong> 的集合。</li><li><strong>List</strong> 代表 <strong>有序、可重复</strong> 的集合。</li><li><strong>Map</strong> 代表具有 <strong>映射关系</strong> 的集合。</li><li><strong>Queue</strong> 代表 <strong>队列</strong> 集合。</li></ul><h4 id="Java-集合和数组的区别"><a href="#Java-集合和数组的区别" class="headerlink" title="Java 集合和数组的区别"></a>Java 集合和数组的区别</h4><ul><li><p><strong>长度</strong> </p><ul><li><strong>数组</strong> 的长度在初始化时指定，意味着只能存 <strong>定长</strong> 的数据。</li><li><strong>集合</strong> 可以保存 <strong>数量不确定</strong> 的数据。也可以保存具有<strong>映射关系</strong> 的数据( key - value )。</li></ul></li><li><p><strong>元素类型</strong> </p><ul><li><strong>数组</strong> 既可以保存基本类型的值，也可以保存对象。</li><li><strong>集合</strong> 只能保存对象（实际为对象的引用），基本类型必须转换成相应的封装类才可放入集合。</li></ul></li></ul><a id="more"></a><h4 id="集合类之间的继承关系"><a href="#集合类之间的继承关系" class="headerlink" title="集合类之间的继承关系"></a>集合类之间的继承关系</h4><ul><li><img src="/images/Collection.png" alt="Collection"> </li><li><img src="/images/Map.png" alt="Map"> </li></ul><h4 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h4><ul><li><p><code>Collection</code> 接口是<code>Set</code> , <code>Queue</code> , <code>List</code> 的父接口。</p></li><li><p><code>Collection</code> 接口中定义了多种数据操作的方法可供子类进行实现（以下为JDK10版本）。<a href="https://docs.oracle.com/javase/10/docs/api/java/util/Collection.html" target="_blank" rel="noopener">JDK Collection</a> </p></li></ul><table><thead><tr><th>Modifier and Type</th><th>Method</th><th>Desc</th></tr></thead><tbody><tr><td>Boolean</td><td>add(E e)</td><td>Ensures that this collection contains the specified element (optional operation).</td></tr><tr><td>boolean</td><td>addAll(Collection&lt;? extends E&gt; c)</td><td>Adds all of the elements in the specified collection to this collection (optional operation).</td></tr><tr><td>void</td><td>clear()</td><td>Removes all of the elements from this collection (optional operation).</td></tr><tr><td>boolean</td><td>contains(Object o)</td><td>Returns true if this collection contains the specified element.</td></tr><tr><td>boolean</td><td>containsAll(Collection&lt;?&gt; c)</td><td>Returns <code>true</code> if this collection contains all of the elements in the specified collection.</td></tr><tr><td>boolean</td><td>equals(Object o)</td><td>Compares the specified object with this collection for equality.</td></tr><tr><td>int</td><td>hashCode()</td><td>Returns the hash code value for this collection.</td></tr><tr><td>boolean</td><td>isEmpty()</td><td>Returns <code>true</code> if this collection contains no elements.</td></tr><tr><td>Iterator<e></e></td><td>iterator()</td><td>Returns an iterator over the elements in this collection.</td></tr><tr><td>default Stream<e></e></td><td>parallelStream()</td><td>Returns a possibly parallel <code>Stream</code> with this collection as its source.</td></tr><tr><td>boolean</td><td>remove(Object o)</td><td>Removes a single instance of the specified element from this collection, if it is present (optional operation).</td></tr><tr><td>boolean</td><td>removeAll(Collection&lt;?&gt; c)</td><td>Removes all of this collection’s elements that are also contained in the specified collection (optional operation).</td></tr><tr><td>default boolean</td><td>removeIf(Predicate&lt;? super E&gt; filter)</td><td>Removes all of the elements of this collection that satisfy the given predicate.</td></tr><tr><td>boolean</td><td>retainAll(Collection&lt;?&gt; c)</td><td>Retains only the elements in this collection that are contained in the specified collection (optional operation).</td></tr><tr><td>int</td><td>size()</td><td>Returns the number of elements in this collection.</td></tr><tr><td>default Spliterator<e></e></td><td>spliterator()</td><td>Creates a <a href="https://docs.oracle.com/javase/10/docs/api/java/util/Spliterator.html" target="_blank" rel="noopener"><code>Spliterator</code></a> over the elements in this collection.</td></tr><tr><td>default Stream<e></e></td><td>stream()</td><td>Returns a sequential <code>Stream</code> with this collection as its source.</td></tr><tr><td>Object[]</td><td>toArray()</td><td>Returns an array containing all of the elements in this collection.</td></tr><tr><td><t> T[]</t></td><td>toArray(T[] a)</td><td>Returns an array containing all of the elements in this collection; the runtime type of the returned array is that of the specified array.</td></tr></tbody></table><h4 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h4><ul><li><code>Set 集合</code> 与 <code>Collection 集合</code> 基本相同，没有提供额外的方法。</li><li>只是<code>Set</code> 行为略有不同，<strong>不允许包含重复元素</strong> 。</li><li>如果试图添加两个<strong>相同</strong> 的元素到同一个<code>Set集合</code> 中，则添加操作失败，<code>add()</code> 方法返回 <code>false</code> ，且新元素不会被加入。</li></ul><h4 id="List-集合"><a href="#List-集合" class="headerlink" title="List 集合"></a>List 集合</h4><ul><li><p><code>List 集合</code> ，<strong>元素有序、可重复</strong> 。集合中每个元素都有其对应的顺序索引。</p></li><li><p><code>List</code> <strong>允许使用重复</strong> 的元素。</p></li><li><p>可以通过索引来访问指定位置的集合元素。</p></li><li><p>默认按元素的添加顺序设置元素的索引。</p></li><li><p><code>List</code> 可以使用 <code>Collection</code> 接口里的所有方法。而且由于 List 为<strong>有序集合</strong> ，<strong>额外增加</strong> 了一些根据索引来操作集合元素的方法。</p></li></ul><table><thead><tr><th>Modifier and Type</th><th>Method</th><th>Desc</th></tr></thead><tbody><tr><td>void</td><td>add(int index, E element)</td><td>Inserts the specified element at the specified position in this list (optional operation).</td></tr><tr><td>boolean</td><td>addAll(int index, Collection&lt;? extends E&gt; c)</td><td>Inserts all of the elements in the specified collection into this list at the specified position (optional operation).</td></tr><tr><td>E</td><td>get(int index)</td><td>Returns the element at the specified position in this list.</td></tr><tr><td>int</td><td>indexOf(Object o)</td><td>Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element.</td></tr><tr><td>int</td><td>lastIndexOf(Object o)</td><td>Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element.</td></tr><tr><td>E</td><td>remove(int index)</td><td>Removes the element at the specified position in this list (optional operation).</td></tr><tr><td>E</td><td>set(int index, E element)</td><td>Replaces the element at the specified position in this list with the specified element (optional operation).</td></tr><tr><td>List<e></e></td><td>subList(int fromIndex, int toIndex)</td><td>Returns a view of the portion of this list between the specified <code>fromIndex</code>, inclusive, and <code>toIndex</code>, exclusive.</td></tr><tr><td>Object[]</td><td>toArray()</td><td>Returns an array containing all of the elements in this list in proper sequence (from first to last element).</td></tr><tr><td>default void</td><td>replaceAll(UnaryOperator<e> operator)</e></td><td>Replaces each element of this list with the result of applying the operator to that element.</td></tr><tr><td>default void</td><td>sort(Comparator&lt;? super E&gt; c)</td><td>Sorts this list according to the order induced by the specified <a href="https://docs.oracle.com/javase/10/docs/api/java/util/Comparator.html" target="_blank" rel="noopener"><code>Comparator</code></a>.</td></tr></tbody></table><h4 id="Queue-集合"><a href="#Queue-集合" class="headerlink" title="Queue 集合"></a>Queue 集合</h4><ul><li><code>队列</code> 数据结构。队列通常是指<strong>先进先出 FIFI</strong> 的容器。</li><li>通常，队列不允许随机访问队列中的元素。</li></ul><table><thead><tr><th>Modifier and Type</th><th>Method</th><th>Desc</th></tr></thead><tbody><tr><td>boolean</td><td>add(E e)</td><td>Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning <code>true</code> upon success and throwing an <code>IllegalStateException</code> if no space is currently available.</td></tr><tr><td>E</td><td>element()</td><td>Retrieves, but does not remove, the head of this queue.</td></tr><tr><td>boolean</td><td>offer(E e)</td><td>Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions.</td></tr><tr><td>E</td><td>peek()</td><td>Retrieves, but does not remove, the head of this queue, or returns <code>null</code> if this queue is empty.</td></tr><tr><td>E</td><td>poll()</td><td>Retrieves and removes the head of this queue, or returns <code>null</code> if this queue is empty.</td></tr><tr><td>E</td><td>remove()</td><td>Retrieves and removes the head of this queue.</td></tr></tbody></table><h4 id="Map-集合"><a href="#Map-集合" class="headerlink" title="Map 集合"></a>Map 集合</h4><ul><li><p><code>Map</code> 保存具有映射关系的数据。<code>key</code> 和 <code>value</code> 都可以是任何引用类型的数据。</p></li><li><p><code>key</code> <strong>不允许重复</strong> 。key 和 value 之间存在单向一对一关系。</p></li><li><p><code>Map</code> 与 <code>Set</code> <code>List</code> 的关系</p><ul><li><p>与<code>Set</code> 的关系：</p><ul><li>如果把<code>Map</code> 里的所有<code>key</code> 放在一起看，它们就组成了一个<code>Set</code> 集合（<code>key</code> 没有顺序，且不可重复）。</li><li>实际上<code>Map</code> 有一个 <code>keySet()</code> 方法，返回<code>Map</code> 里所有<code>key</code> 组成的<code>Set</code> 集合。</li></ul></li><li><p>与 <code>List</code> 的关系：</p><ul><li>如果把<code>Map</code> 里的所有<code>value</code> 放在一起看，它们又非常类似于一个 <code>List</code> （<code>value</code> 可重复，每个元素根据索引来查找）。</li></ul></li></ul></li><li><p><code>Map</code> 接口中定义的方法：</p></li></ul><table><thead><tr><th>Modifier and Type</th><th>Method</th><th>Desc</th></tr></thead><tbody><tr><td>void</td><td>clear()</td><td>Removes all of the mappings from this map (optional operation).</td></tr><tr><td>boolean</td><td>containsKey(Object key)</td><td>Returns <code>true</code> if this map contains a mapping for the specified key.</td></tr><tr><td>boolean</td><td>containsValue(Object value)</td><td>Returns <code>true</code> if this map maps one or more keys to the specified value.</td></tr><tr><td>Set&lt;Map.Entry&lt;K, V&gt;&gt;</td><td>entrySet()</td><td>Returns a <a href="https://docs.oracle.com/javase/10/docs/api/java/util/Set.html" target="_blank" rel="noopener"><code>Set</code></a> view of the mappings contained in this map.</td></tr><tr><td>boolean</td><td>equals(Object o)</td><td>Compares the specified object with this map for equality.</td></tr><tr><td>V</td><td>get(Object key)</td><td>Returns the value to which the specified key is mapped, or <code>null</code> if this map contains no mapping for the key.</td></tr><tr><td>int</td><td>hashCode()</td><td>Returns the hash code value for this map.</td></tr><tr><td>boolean</td><td>isEmpty()</td><td>Returns <code>true</code> if this map contains no key-value mappings.</td></tr><tr><td>Set<k></k></td><td>keySet()</td><td>Returns a <a href="https://docs.oracle.com/javase/10/docs/api/java/util/Set.html" target="_blank" rel="noopener"><code>Set</code></a> view of the keys contained in this map.</td></tr><tr><td>V</td><td>put(K key, V value)</td><td>Associates the specified value with the specified key in this map (optional operation).</td></tr><tr><td>void</td><td>putAll(Map&lt;? extends K, ? extends V&gt; m)</td><td>Copies all of the mappings from the specified map to this map (optional operation).</td></tr><tr><td>V</td><td>remove(Object key)</td><td>Removes the mapping for a key from this map if it is present (optional operation).</td></tr><tr><td>int</td><td>size()</td><td>Returns the number of key-value mappings in this map.</td></tr><tr><td>Collection<v></v></td><td>values()</td><td>Returns a <a href="https://docs.oracle.com/javase/10/docs/api/java/util/Collection.html" target="_blank" rel="noopener"><code>Collection</code></a> view of the values contained in this map.</td></tr></tbody></table><ul><li><code>Map</code> 还包含一个<strong>内部类</strong> <code>Entry</code> ，该类封装了一个<code>key-value</code> 对。</li></ul><table><thead><tr><th>Modifier and Type</th><th>Method</th><th>Desc</th></tr></thead><tbody><tr><td>boolean</td><td>equals(Object o)</td><td>Compares the specified object with this entry for equality.</td></tr><tr><td>K</td><td>getKey()</td><td>Returns the key corresponding to this entry.</td></tr><tr><td>V</td><td>getValue()</td><td>Returns the value corresponding to this entry.</td></tr><tr><td>int</td><td>hashCode()</td><td>Returns the hash code value for this map entry.</td></tr><tr><td>V</td><td>setValue(V value)</td><td>Replaces the value corresponding to this entry with the specified value (optional operation).</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/589d58033841&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ruheng - 由浅入深理解java集合(一)——集合框架 Collection、Map&lt;/a&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;集合简介&quot;&gt;&lt;a href=&quot;#集合简介&quot; class=&quot;headerlink&quot; title=&quot;集合简介&quot;&gt;&lt;/a&gt;集合简介&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Java 集合&lt;/strong&gt; 大致可分为&lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;List&lt;/code&gt; , &lt;code&gt;Queue&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; 四大体系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Set&lt;/strong&gt; 代表 &lt;strong&gt;无序、不可重复&lt;/strong&gt; 的集合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;List&lt;/strong&gt; 代表 &lt;strong&gt;有序、可重复&lt;/strong&gt; 的集合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Map&lt;/strong&gt; 代表具有 &lt;strong&gt;映射关系&lt;/strong&gt; 的集合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Queue&lt;/strong&gt; 代表 &lt;strong&gt;队列&lt;/strong&gt; 集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Java-集合和数组的区别&quot;&gt;&lt;a href=&quot;#Java-集合和数组的区别&quot; class=&quot;headerlink&quot; title=&quot;Java 集合和数组的区别&quot;&gt;&lt;/a&gt;Java 集合和数组的区别&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;长度&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数组&lt;/strong&gt; 的长度在初始化时指定，意味着只能存 &lt;strong&gt;定长&lt;/strong&gt; 的数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集合&lt;/strong&gt; 可以保存 &lt;strong&gt;数量不确定&lt;/strong&gt; 的数据。也可以保存具有&lt;strong&gt;映射关系&lt;/strong&gt; 的数据( key - value )。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;元素类型&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数组&lt;/strong&gt; 既可以保存基本类型的值，也可以保存对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集合&lt;/strong&gt; 只能保存对象（实际为对象的引用），基本类型必须转换成相应的封装类才可放入集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="集合" scheme="http://echoguan.coding.me/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Blog - hexo + yilia 博客访问量统计显示</title>
    <link href="http://echoguan.coding.me/2018/11/12/hexo-yilia-%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E9%87%8F%E7%BB%9F%E8%AE%A1%E6%98%BE%E7%A4%BA/"/>
    <id>http://echoguan.coding.me/2018/11/12/hexo-yilia-博客访问量统计显示/</id>
    <published>2018-11-12T07:06:18.000Z</published>
    <updated>2019-05-20T11:03:00.505Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-网站访问量显示"><a href="#1-网站访问量显示" class="headerlink" title="1. 网站访问量显示"></a>1. 网站访问量显示</h4><ul><li><p>效果</p><ul><li>见博客底部</li></ul></li><li><p>实现</p><ul><li><p>使用 <strong><a href="http://ibruce.info/" target="_blank" rel="noopener">不蒜子</a></strong> ，可以看官方介绍。</p></li><li><p>在 <code>themes/yilia/layout/_partial/footer.ejs</code> 中加入如下代码：</p></li><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 根据个人喜好在相应位置添加以下代码 --&gt;</span><br><span class="line">&lt;div calss=<span class="string">"count-span"</span>&gt;</span><br><span class="line">    &lt;span id=<span class="string">"busuanzi_container_site_pv"</span>&gt;</span><br><span class="line">    总访问量: &lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;|</span><br><span class="line">    &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span id="busuanzi_container_site_uv"&gt;</span></span><br><span class="line"><span class="regexp">    总访客: &lt;span id="busuanzi_value_site_uv"&gt;&lt;/</span>span&gt;</span><br><span class="line">    &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line">&lt;!-- 根据个人喜好在相应位置添加以上代码 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>然后重新部署发布博客即可。</p></li></ul></li></ul><h4 id="2-网站-IP-访问量显示-友盟"><a href="#2-网站-IP-访问量显示-友盟" class="headerlink" title="2. 网站 IP 访问量显示(友盟)"></a>2. 网站 IP 访问量显示(友盟)</h4><ul><li><p>使用<a href="http://www.umeng.com/" target="_blank" rel="noopener">友盟</a> </p></li><li><p>首先注册一个帐号-&gt;进入个人中心-&gt;展开全部产品-&gt;选择<strong>U-Web网站统计</strong>-&gt;点击<strong>立即使用</strong>-&gt;<strong>添加站点</strong></p></li><li><p>然后在<code>站点设置</code> 里选择<code>获取代码</code> ，我这里选择的是 <code>横排数据显示</code> 。</p></li><li><p>然后把自己的代码加到 <code>footer.ejs</code> 中</p></li><li><p>可在<code>友盟</code>上查看最近的<strong>访问量</strong>和<strong>数据</strong> 。</p></li></ul><h4 id="3-文章访问量统计"><a href="#3-文章访问量统计" class="headerlink" title="3. 文章访问量统计"></a>3. 文章访问量统计</h4><ul><li>下面这段代码添加在<code>/themes/yilia/layout/_partial/article.ejs</code> 的header的日期后面：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 添加判断，如果首页则不显示访问量</span><br><span class="line">&lt;% if ( !index )&#123; %&gt;</span><br><span class="line">    &lt;span class=&quot;archive-article-date&quot;&gt;</span><br><span class="line">        阅读量 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://meetes.top/2018/01/31/Hexo%20+%20yilia%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%84%E6%89%80%E6%9C%89%E7%96%91%E9%97%AE/" target="_blank" rel="noopener">Hexo + yilia 搭建博客可能会遇到的所有疑问</a> </p><p><a href="http://www.lookk.cn/2017/12/09/hexo-yilia%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E8%AE%BF%E9%97%AE%E9%87%8F%E7%BB%9F%E8%AE%A1/" target="_blank" rel="noopener">hexo yilia主题添加文章访问量统计</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-网站访问量显示&quot;&gt;&lt;a href=&quot;#1-网站访问量显示&quot; class=&quot;headerlink&quot; title=&quot;1. 网站访问量显示&quot;&gt;&lt;/a&gt;1. 网站访问量显示&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;效果&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;见博客底部&lt;/li&gt;
&lt;/ul
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="hexo" scheme="http://echoguan.coding.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java - 枚举类型介绍总结</title>
    <link href="http://echoguan.coding.me/2018/10/14/Java-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D%E6%80%BB%E7%BB%93/"/>
    <id>http://echoguan.coding.me/2018/10/14/Java-枚举类型介绍总结/</id>
    <published>2018-10-14T13:18:14.000Z</published>
    <updated>2019-05-20T11:03:00.521Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>枚举类型（<code>enum type</code>）是指由一组固定的常量组成合法的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season &#123;</span><br><span class="line">    SPRING, SUMMER, AUTUMN, WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>特点：</p><ul><li>使用关键字<code>enum</code> </li><li>类型名称，如<code>Season</code> </li><li>一串允许的值（<code>SPRING, SUMMER, AUTUMN, WINTER</code>）</li><li>枚举可以单独定义在一个文件中，也可以嵌在其它 <code>Java类</code> 中。</li><li><code>枚举类型</code> 可以实现一个或多个接口</li><li>可以定义新的变量</li><li>可以定义新的方法</li><li>可以定义根据具体枚举值而相异的类</li></ul></li><li><p>应用举例：</p><blockquote><p><a href="http://www.hollischuang.com/archives/195" target="_blank" rel="noopener">Hollis - Java的枚举类型用法介绍</a> </p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;枚举类型（&lt;code&gt;enum type&lt;/code&gt;）是指由一组固定的常量组成合法的类型。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Interview" scheme="http://echoguan.coding.me/tags/Interview/"/>
    
      <category term="枚举类型" scheme="http://echoguan.coding.me/tags/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android - Ramp Up 笔记</title>
    <link href="http://echoguan.coding.me/2018/09/11/Android-Ramp-Up-Memo/"/>
    <id>http://echoguan.coding.me/2018/09/11/Android-Ramp-Up-Memo/</id>
    <published>2018-09-11T02:40:21.000Z</published>
    <updated>2019-05-20T11:03:00.501Z</updated>
    
    <content type="html"><![CDATA[<h4 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h4><h5 id="1-setError-amp-setErrorEnabled"><a href="#1-setError-amp-setErrorEnabled" class="headerlink" title="1. setError &amp; setErrorEnabled"></a>1. setError &amp; setErrorEnabled</h5><ul><li><p>正确使用顺序应该是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BindView</span>(R.id.til_username_body)</span><br><span class="line">TextInputLayout tilUsername;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add error</span></span><br><span class="line">tilUsername.setError(<span class="string">"error here!!"</span>); <span class="comment">// setError 会自动调用 setErrorEnabled(true)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// romeve error</span></span><br><span class="line">tilUsername.setError(<span class="keyword">null</span>);</span><br><span class="line">tilUsername.setErrorEnabled(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><ul><li><strong>Acceptance Criteria</strong> </li><li>MVP, Dagger2, Retrofit, RxJava, Unit test</li></ul><h4 id="MVP-Pattern"><a href="#MVP-Pattern" class="headerlink" title="MVP Pattern"></a>MVP Pattern</h4><ul><li><p>Model-View-Presenter</p></li><li><p>是由 <code>MVC</code> 演变而来。在 <code>MVP</code> 中：</p><ul><li><code>View</code> 更加专注于处理数据可视化和页面交互</li><li><code>Model</code> 更加专注于数据的处理</li><li><code>Presenter</code> 则提供 <code>View</code> 和 <code>Model</code> 之间数据的纽带，用于交互和数据传输</li></ul></li><li><p><strong><code>View</code>不直接与<code>Model</code>交互</strong> </p></li><li><h4 id="MVP-in-four-bullet-points"><a href="#MVP-in-four-bullet-points" class="headerlink" title="MVP in four bullet points"></a>MVP in four bullet points</h4><ul><li>MVP stands for Model-View-Presenter.</li><li>The “Model” is your data source, doesn’t matter if a database, network calls or a hard-coded list of objects.</li><li>The “View” is your Activity, Fragment or custom Android View. Which should just take care of displaying things and handling user interaction.</li><li>The “Presenter” is a plain old java object (POJO) that handles the communication between the View and the Model, makes any required data transformations, handles errors from the Model and tries to remove as much UX logic from the View as possible.</li></ul></li></ul><blockquote><p><a href="https://blog.csdn.net/u011418943/article/details/69840880" target="_blank" rel="noopener">MVP 设计模式理解，实战理解MVP</a> </p><p><a href="https://www.jianshu.com/p/9a6845b26856" target="_blank" rel="noopener">Android MVP 详解（上）</a> </p></blockquote><a id="more"></a><h4 id="RxJava-RxAndroid"><a href="#RxJava-RxAndroid" class="headerlink" title="RxJava/RxAndroid"></a>RxJava/RxAndroid</h4><ul><li><p><code>RxJava</code> 的本质可以压缩为<strong>异步</strong>这一个词。说到根上，它就是一个实现异步操作的库，而别的定语都是基于这之上的。</p></li><li><p>优势：<strong>简洁</strong></p></li><li><p><code>RxJava</code> 的异步实现，是通过一种扩展的<strong>观察者模式</strong>来实现的。</p></li><li><p><code>RxJava</code> 有四个基本概念：<strong>Observable</strong> (可观察者，即被观察者)、 <strong>Observer</strong> (观察者)、<strong>subscribe</strong> (订阅)、<strong>事件</strong>。</p></li><li><p><code>RxJava</code> 的观察者模式大致如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2405826-1b43cf8a80bfca3f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/599/format/webp" alt="img"></p></li></ul><blockquote><p><a href="https://www.jianshu.com/p/10d4d7c69345" target="_blank" rel="noopener">Rxjava、RxAndroid系列</a></p></blockquote><h4 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h4><ul><li><code>Retrofit</code> 是 Square 的一个著名的<strong>网络请求库</strong>。</li><li><code>Retrofit</code> 除了提供了传统的 Callback 形式的 <code>API</code>，还有 <code>RxJava</code> 版本的 Observable 形式 <code>API</code>。</li></ul><h4 id="Robolectric"><a href="#Robolectric" class="headerlink" title="Robolectric"></a>Robolectric</h4><ul><li><code>gradlew clean build</code></li></ul><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><ul><li><p>构成应用的组件主要有四种：<code>Activities</code>活动、<code>Services</code> 服务、<code>Broadcast Receivers</code> 广播接收器 和 <code>Content Providers</code> 内容提供者。</p></li><li><p><code>Android Manifest</code> 用于向 Android 框架<strong>注册组件</strong>。</p></li><li><p><code>Activity</code>：Single focused thing that the user can do.(用户可以执行的单一任务)</p><ul><li><p>负责<strong>显示应用用户界面</strong>。</p></li><li><p><code>Activity</code> 通过读取 <code>XML布局文件</code> 确定要创建哪些视图（并放在何处）。</p></li><li><blockquote><p><a href="https://classroom.udacity.com/courses/ud851/lessons/93affc67-3f0b-4f9b-b3a4-a7a26f241a86/concepts/cdbfd437-de24-4903-8f01-37c29427cb38#" target="_blank" rel="noopener">Android 布局入门</a></p></blockquote></li></ul></li><li><p><code>Layout</code> </p><ul><li>分为三种：<code>FrameLayout</code> 帧布局、 <code>LinearLayout</code> 线性布局、 <code>ConstraintLayout</code> 约束布局</li></ul></li><li><p><code>AsyncTask</code> : 在 Android <strong>线程之间</strong>进行线程和消息<strong>传递</strong>的有用抽象类。</p></li><li><p>Tips: </p><ul><li><code>Android</code> 特殊的<strong>日志</strong>级别：<code>WTF(What a Terrible Failure)</code> &gt; <code>ERROR</code> </li><li><code>Json</code> : <strong>Java Script Object Notation</strong> </li></ul></li><li><p>设置</p><ul><li>proxy</li><li>Gradle -&gt; offline work 选上</li><li>Compiler -&gt; Configure on demand 不选</li></ul></li></ul><h4 id="大坑"><a href="#大坑" class="headerlink" title="大坑"></a>大坑</h4><h5 id="Android-Studio-Gradle-Sync-Failed-错误"><a href="#Android-Studio-Gradle-Sync-Failed-错误" class="headerlink" title="Android Studio Gradle Sync Failed 错误"></a>Android Studio <code>Gradle Sync Failed</code> 错误</h5><ul><li><p>出现错误的原因：<strong>Android Studio 需要设置代理 FQ</strong></p><ul><li><p><code>settings</code> 搜索 <code>proxy</code> </p></li><li><p>我是用 ShadowSocks ，设置如下图：</p><p><img src="/images/AndroidStudioProxy.png" alt="Proxy Setting"> </p></li></ul><blockquote><p><a href="https://blog.csdn.net/lchad/article/details/43567675" target="_blank" rel="noopener">【Android】给Android Studio设置代理</a> </p></blockquote></li></ul><h4 id="ButterKnife"><a href="#ButterKnife" class="headerlink" title="ButterKnife"></a>ButterKnife</h4><ul><li><p><strong>ButterKnife</strong> 是一个 <code>Android</code> 系统的 <code>View</code> 注入框架，能够通过『注解』的方式来绑定 <code>View</code> 的属性或方法。</p></li><li><p>比如使用它能够减少 <code>findViewById()</code> 的书写，使代码更为简洁明了，同时不消耗额外的性能。</p><blockquote><p><a href="https://www.jianshu.com/p/1d80c7dd01ba" target="_blank" rel="noopener">[Android] ButterKnife 浅析</a> </p><p><a href="https://www.jianshu.com/p/952c6f5e8157" target="_blank" rel="noopener">https://www.jianshu.com/p/952c6f5e8157</a> </p></blockquote></li></ul><h5 id="Activity-生命周期"><a href="#Activity-生命周期" class="headerlink" title="Activity 生命周期"></a>Activity 生命周期</h5><ul><li>onCreate() - onStart() - onResume() - onPause() - onStop() - onRestart() - onDestory() </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;遇到的一些问题&quot;&gt;&lt;a href=&quot;#遇到的一些问题&quot; class=&quot;headerlink&quot; title=&quot;遇到的一些问题&quot;&gt;&lt;/a&gt;遇到的一些问题&lt;/h4&gt;&lt;h5 id=&quot;1-setError-amp-setErrorEnabled&quot;&gt;&lt;a href=&quot;#1-setError-amp-setErrorEnabled&quot; class=&quot;headerlink&quot; title=&quot;1. setError &amp;amp; setErrorEnabled&quot;&gt;&lt;/a&gt;1. setError &amp;amp; setErrorEnabled&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;正确使用顺序应该是&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@BindView&lt;/span&gt;(R.id.til_username_body)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TextInputLayout tilUsername;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// add error&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tilUsername.setError(&lt;span class=&quot;string&quot;&gt;&quot;error here!!&quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// setError 会自动调用 setErrorEnabled(true)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// romeve error&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tilUsername.setError(&lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tilUsername.setErrorEnabled(&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Demo&quot;&gt;&lt;a href=&quot;#Demo&quot; class=&quot;headerlink&quot; title=&quot;Demo&quot;&gt;&lt;/a&gt;Demo&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Acceptance Criteria&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;MVP, Dagger2, Retrofit, RxJava, Unit test&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;MVP-Pattern&quot;&gt;&lt;a href=&quot;#MVP-Pattern&quot; class=&quot;headerlink&quot; title=&quot;MVP Pattern&quot;&gt;&lt;/a&gt;MVP Pattern&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Model-View-Presenter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;是由 &lt;code&gt;MVC&lt;/code&gt; 演变而来。在 &lt;code&gt;MVP&lt;/code&gt; 中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;View&lt;/code&gt; 更加专注于处理数据可视化和页面交互&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Model&lt;/code&gt; 更加专注于数据的处理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Presenter&lt;/code&gt; 则提供 &lt;code&gt;View&lt;/code&gt; 和 &lt;code&gt;Model&lt;/code&gt; 之间数据的纽带，用于交互和数据传输&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;View&lt;/code&gt;不直接与&lt;code&gt;Model&lt;/code&gt;交互&lt;/strong&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h4 id=&quot;MVP-in-four-bullet-points&quot;&gt;&lt;a href=&quot;#MVP-in-four-bullet-points&quot; class=&quot;headerlink&quot; title=&quot;MVP in four bullet points&quot;&gt;&lt;/a&gt;MVP in four bullet points&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;MVP stands for Model-View-Presenter.&lt;/li&gt;
&lt;li&gt;The “Model” is your data source, doesn’t matter if a database, network calls or a hard-coded list of objects.&lt;/li&gt;
&lt;li&gt;The “View” is your Activity, Fragment or custom Android View. Which should just take care of displaying things and handling user interaction.&lt;/li&gt;
&lt;li&gt;The “Presenter” is a plain old java object (POJO) that handles the communication between the View and the Model, makes any required data transformations, handles errors from the Model and tries to remove as much UX logic from the View as possible.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u011418943/article/details/69840880&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MVP 设计模式理解，实战理解MVP&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/9a6845b26856&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android MVP 详解（上）&lt;/a&gt; &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://echoguan.coding.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java - JDK, JRE, JVM简介</title>
    <link href="http://echoguan.coding.me/2018/09/09/JDK-JRE-JVM%E7%AE%80%E4%BB%8B/"/>
    <id>http://echoguan.coding.me/2018/09/09/JDK-JRE-JVM简介/</id>
    <published>2018-09-09T06:01:59.000Z</published>
    <updated>2019-05-20T11:03:00.535Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JDK-Java-Development-ToolKit-Java-开发工具包"><a href="#JDK-Java-Development-ToolKit-Java-开发工具包" class="headerlink" title="JDK(Java Development ToolKit) - Java 开发工具包"></a>JDK(Java Development ToolKit) - Java 开发工具包</h4><ul><li><code>JDK</code> 是整个 Java 的<strong>核心</strong>。</li><li>包括：<ul><li><strong>JRE</strong> - Java 运行环境</li><li><strong>Java API</strong> - Java 基础的<strong>类库</strong> </li><li>一堆<code>Java 工具</code>（javac/java/jdb等）</li></ul></li></ul><h4 id="JRE-Java-Runtime-Environment-Java-运行时环境"><a href="#JRE-Java-Runtime-Environment-Java-运行时环境" class="headerlink" title="JRE(Java Runtime Environment) - Java 运行时环境"></a>JRE(Java Runtime Environment) - Java 运行时环境</h4><ul><li><p>所有的 Java 程序都必须在 <code>JRE</code> 下才能<strong>运行</strong>。</p></li><li><p>包括：</p><ul><li>JVM</li><li>Java 核心类库</li><li>支持文件</li></ul></li></ul><h4 id="JVM-Java-Virtual-Mechinal-Java-虚拟机"><a href="#JVM-Java-Virtual-Mechinal-Java-虚拟机" class="headerlink" title="JVM(Java Virtual Mechinal) - Java 虚拟机"></a>JVM(Java Virtual Mechinal) - Java 虚拟机</h4><ul><li><code>JVM</code> 是 <code>JRE</code> 的一部分。</li><li>它是一个虚构出来的计算机。</li><li><code>JVM</code> 有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。</li><li><code>JVM</code> 的主要工作是，解释自己的编码集，并映射到本地 CPU 的指令集或 OS 的系统调用。</li><li>Java 语言的跨平台特性，其实就是不同的操作系统，使用不同的 JVM 映射规则。</li></ul><p><img src="/images/JDKJREJVM-relation.gif" alt="JDK JRE JVM 关系"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;JDK-Java-Development-ToolKit-Java-开发工具包&quot;&gt;&lt;a href=&quot;#JDK-Java-Development-ToolKit-Java-开发工具包&quot; class=&quot;headerlink&quot; title=&quot;JDK(Java Devel
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JDK" scheme="http://echoguan.coding.me/tags/JDK/"/>
    
      <category term="JRE" scheme="http://echoguan.coding.me/tags/JRE/"/>
    
      <category term="JVM" scheme="http://echoguan.coding.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Spring - 深入理解 Spring IoC</title>
    <link href="http://echoguan.coding.me/2018/08/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Spring-IoC/"/>
    <id>http://echoguan.coding.me/2018/08/05/深入理解-Spring-IoC/</id>
    <published>2018-08-05T08:38:00.000Z</published>
    <updated>2019-05-20T11:03:00.546Z</updated>
    
    <content type="html"><![CDATA[<h4 id="IOC-理论"><a href="#IOC-理论" class="headerlink" title="IOC 理论"></a>IOC 理论</h4><ul><li>IoC 全称为 <code>InversionofControl</code>，翻译为 “控制反转”，它还有一个别名为 DI（ <code>DependencyInjection</code>），即依赖注入。</li><li><strong>所谓 IOC ，就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系。</strong></li><li>IoC 的理念就是<strong>让别人为你服务。</strong></li></ul><ol><li><strong>谁控制谁</strong>：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IOC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。</li><li><strong>控制什么</strong>：控制对象。</li><li><strong>为何是反转</strong>：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。</li><li><strong>哪些方面反转了</strong>：所依赖对象的获取被反转了。</li></ol><ul><li>IOC Service Provider 为被注入对象提供被依赖对象也有如下几种方式：<strong>构造器注入</strong>、<strong>setter 注入</strong>、<strong>接口注入</strong>。</li></ul><blockquote><p><a href="https://mp.weixin.qq.com/s/nCvZ9NbNQeD_FtJyho4owg" target="_blank" rel="noopener">【死磕 Spring】—– IOC 之深入理解 Spring IoC</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;IOC-理论&quot;&gt;&lt;a href=&quot;#IOC-理论&quot; class=&quot;headerlink&quot; title=&quot;IOC 理论&quot;&gt;&lt;/a&gt;IOC 理论&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;IoC 全称为 &lt;code&gt;InversionofControl&lt;/code&gt;，翻译为 “控制反
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Spring" scheme="http://echoguan.coding.me/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>备忘 - IntelliJ IDEA 配置 备忘录</title>
    <link href="http://echoguan.coding.me/2018/07/04/IntelliJ-IDEA-Config-Memo/"/>
    <id>http://echoguan.coding.me/2018/07/04/IntelliJ-IDEA-Config-Memo/</id>
    <published>2018-07-04T13:02:02.000Z</published>
    <updated>2019-05-20T11:03:00.506Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-配置JDK"><a href="#1-配置JDK" class="headerlink" title="1. 配置JDK"></a>1. 配置JDK</h4><h4 id="2-常用设置"><a href="#2-常用设置" class="headerlink" title="2. 常用设置"></a>2. 常用设置</h4><ul><li><p>Theme: Relax Your Eyes Green</p></li><li><p>代码补全取消区分大小写</p><p>Preferences -&gt; 搜索 code completion -&gt; Case sensitive completion 选为 none。</p></li><li><p>自动导包</p></li></ul><p><img src="http://img.phperz.com/data/img/20150923/1443020024_1689.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-配置JDK&quot;&gt;&lt;a href=&quot;#1-配置JDK&quot; class=&quot;headerlink&quot; title=&quot;1. 配置JDK&quot;&gt;&lt;/a&gt;1. 配置JDK&lt;/h4&gt;&lt;h4 id=&quot;2-常用设置&quot;&gt;&lt;a href=&quot;#2-常用设置&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="备忘" scheme="http://echoguan.coding.me/tags/%E5%A4%87%E5%BF%98/"/>
    
      <category term="工具" scheme="http://echoguan.coding.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="JDK" scheme="http://echoguan.coding.me/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>备忘 - Mackbook 新装机</title>
    <link href="http://echoguan.coding.me/2018/07/04/Mackbook-Install-Memo/"/>
    <id>http://echoguan.coding.me/2018/07/04/Mackbook-Install-Memo/</id>
    <published>2018-07-04T05:52:19.000Z</published>
    <updated>2019-05-20T11:03:00.536Z</updated>
    
    <content type="html"><![CDATA[<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol><li>Chrome</li><li>Lantern</li><li>搜狗输入法</li><li>TeamViewer</li><li>有道翻译</li><li>百度云</li><li>QQ</li><li>WeChat</li><li>Parallels Desktop</li><li>Office</li><li>IINA</li></ol><h3 id="Develop-Tools"><a href="#Develop-Tools" class="headerlink" title="Develop Tools"></a>Develop Tools</h3><ol><li>Typora</li><li>iTerm2<ol><li>配色：</li></ol></li><li>VSCode<ol><li>插件：ESlint, Prettier, Auto Close Tag, VSCode Great Icons</li></ol></li><li>GitHub Desktop</li><li>IntelliJ IDEA</li></ol><h3 id="Utils"><a href="#Utils" class="headerlink" title="Utils"></a>Utils</h3><ol><li>Git </li><li>Node</li><li>homebrew</li><li>wget</li><li>Maven</li><li>Java</li><li>MongoDB</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;应用&quot;&gt;&lt;a href=&quot;#应用&quot; class=&quot;headerlink&quot; title=&quot;应用&quot;&gt;&lt;/a&gt;应用&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Chrome&lt;/li&gt;
&lt;li&gt;Lantern&lt;/li&gt;
&lt;li&gt;搜狗输入法&lt;/li&gt;
&lt;li&gt;TeamViewer&lt;/li&gt;

      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="备忘" scheme="http://echoguan.coding.me/tags/%E5%A4%87%E5%BF%98/"/>
    
      <category term="MacBook" scheme="http://echoguan.coding.me/tags/MacBook/"/>
    
  </entry>
  
  <entry>
    <title>备忘 - iTerm2 配色方案</title>
    <link href="http://echoguan.coding.me/2018/07/04/iTerm2-Color-Schemes/"/>
    <id>http://echoguan.coding.me/2018/07/04/iTerm2-Color-Schemes/</id>
    <published>2018-07-04T00:46:01.000Z</published>
    <updated>2019-05-20T11:03:00.520Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录自己配置过程</p></blockquote><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="/images/itrem2-theme-echo.png" alt="iterm2"> </p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><a id="more"></a><ol><li>设置 iTerm2 为<strong>默认终端</strong>：<ul><li>（菜单栏）iTerm2 -&gt; Make iTerm2 Default Term </li></ul></li><li>全局热键启动和关闭 iTerm2：<ul><li>偏好设置 preferences -&gt; Keys -&gt; 勾选 Hotkey 下的 Show/hide iTerm2 with a system-wide hotkey，将热键设置为command+i</li></ul></li><li>Mac OS X 上修改主机名：<code>sudo scutil --set HostName MacBookPro</code></li><li>透明度：偏好设置 preferences -&gt; Profiles，右侧找到window选项卡，拖动Transparency调整。</li></ol><h4 id="配色方案"><a href="#配色方案" class="headerlink" title="配色方案"></a>配色方案</h4><ul><li>我选用的是 <a href="http://ethanschoonover.com/solarized" target="_blank" rel="noopener">solarized</a>，点开官网，下载，解压。</li><li>然后打开 iTerm2 下的偏好设置 preference ，点开 profiles 下的 colors 选项，点击右下角的 Color Presets  选项，选择 import ，导入解压到的 solarized 文件下的 Solarized Dark.itermcolors。</li><li>然后勾选 Solarized Dark。</li></ul><h4 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh-my-zsh"></a>安装 <a href="http://ohmyz.sh/" target="_blank" rel="noopener">oh-my-zsh</a></h4><ol><li>命令行输入 <code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></li><li><code>nano ~/.zshrc</code>，修改为 <code>ZSH_THEME=&quot;ys&quot;</code></li></ol><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><ol><li><a href="https://link.jianshu.com/?t=http://mimosa-pudica.net/zsh-incremental.html" target="_blank" rel="noopener">incr.zsh</a> 自动补齐插件 - 不好用，无法粘贴命令</li><li>highlight 插件</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录自己配置过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/itrem2-theme-echo.png&quot; alt=&quot;iterm2&quot;&gt; &lt;/p&gt;
&lt;h4 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h4&gt;
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="备忘" scheme="http://echoguan.coding.me/tags/%E5%A4%87%E5%BF%98/"/>
    
      <category term="工具" scheme="http://echoguan.coding.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 - Facade 外观模式/门面模式</title>
    <link href="http://echoguan.coding.me/2018/06/29/Facade-Pattern/"/>
    <id>http://echoguan.coding.me/2018/06/29/Facade-Pattern/</id>
    <published>2018-06-29T02:18:08.000Z</published>
    <updated>2019-05-20T11:03:00.502Z</updated>
    
    <content type="html"><![CDATA[<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li><p>The intent of the Facade is to provide a high-level interface (properties and methods) that makes a subsystem or toolkit easy to use for the client. </p><p>统一入口，简化调用</p></li><li><p>The Facade exposes only what is necessary and presents a cleaner and easy-to-use interface. </p><p>降低依赖，松耦合</p></li></ul><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ul><li>It is often present in systems that are built around a multi-layer architecture. </li><li>Facades themselves are often implemented as singleton factories. </li></ul><h5 id="Diagram"><a href="#Diagram" class="headerlink" title="Diagram"></a>Diagram</h5><p><img src="https://www.dofactory.com/images/diagrams/javascript/javascript-facade.jpg" alt="Diagram JavaScript Facade  Design Pattern"> </p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><blockquote><p><a href="https://www.dofactory.com/javascript/facade-design-pattern" target="_blank" rel="noopener">facade-design-pattern</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The intent of the Facade is to provide a high-level interface
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="设计模式" scheme="http://echoguan.coding.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
