<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>echo</title>
  
  <subtitle>十年大计，日拱一卒</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://echoguan.coding.me/"/>
  <updated>2018-11-23T10:54:02.816Z</updated>
  <id>http://echoguan.coding.me/</id>
  
  <author>
    <name>Echo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java - equals() 和 hashCode() 方法</title>
    <link href="http://echoguan.coding.me/2018/11/23/Java-equals%E5%92%8ChashCode%E6%96%B9%E6%B3%95/"/>
    <id>http://echoguan.coding.me/2018/11/23/Java-equals和hashCode方法/</id>
    <published>2018-11-23T06:53:22.000Z</published>
    <updated>2018-11-23T10:54:02.816Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote><h3 id="hashCode-和-equals-方法的作用？什么时候必须重写？"><a href="#hashCode-和-equals-方法的作用？什么时候必须重写？" class="headerlink" title="hashCode() 和 equals() 方法的作用？什么时候必须重写？"></a><code>hashCode()</code> 和 <code>equals()</code> 方法的作用？什么时候必须重写？</h3><ul><li><code>equals(Object obj)</code> 方法用来判断两个对象是否相等。<ul><li>Indicates whether some other object is “equal to” this one.</li></ul></li><li><code>hashCode()</code> 方法用来返回对象的哈希码。(哈希码作用是确定该对象在散列存储结构中的存储位置)<ul><li>Returns a hash code value for the object.</li></ul></li><li>这两个方法的规范：<ul><li>如果两个对象相同，<code>equals()</code> 方法一定返回<code>true</code> ，并且这两个对象的<code>hashCode()</code> 相同。</li><li>如果两个对象的<code>hashCode()</code> 相同，不代表两个对象就相同。只能说明这两个对象在散列存储结构中，存放在同一个位置。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;hashCode-和-equals-方法的作用？什么时候必须重写？&quot;&gt;&lt;a href=&quot;#hashCode-和-equals-方法的作用？什么时候必须重写？&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://echoguan.coding.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java - 集合Set(2) - Note</title>
    <link href="http://echoguan.coding.me/2018/11/23/Java-%E9%9B%86%E5%90%88Set-2/"/>
    <id>http://echoguan.coding.me/2018/11/23/Java-集合Set-2/</id>
    <published>2018-11-23T06:10:04.000Z</published>
    <updated>2018-11-23T07:07:38.054Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote><blockquote><p><code>Set</code>  <strong>不允许包含重复元素</strong> 。</p></blockquote><h3 id="HashSet-类"><a href="#HashSet-类" class="headerlink" title="HashSet 类"></a>HashSet 类</h3><ul><li><code>HashSet</code> 简介<ul><li><code>HashSet</code> 是<code>Set接口</code> 的典型实现。</li><li>实现了<code>Set接口</code> 中的所有方法，并没有添加额外的方法。</li><li><code>HashSet</code> 按 <code>Hash 算法</code> 来存储集合中的元素，因此<strong>具有很好的存取和查找性能</strong> 。</li></ul></li></ul><ul><li>特点<ul><li><strong>不能保证元素的排列顺序</strong> 。顺序可能与添加的顺序不同，顺序也可能发生变化。</li><li><strong>HashSet 不是同步的</strong> 。</li><li>集合元素可以是 <code>null</code> 。</li><li>判断两个元素是否相等的标准是：<ol><li>两个对象通过<code>equals()</code> 方法比较相等。</li><li>并且，两个对象的<code>hashCode()</code> 方法的返回值也相等。</li></ol></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Set&lt;/code&gt;  &lt;strong&gt;不允许包含重复元素&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;HashSet-类&quot;&gt;&lt;a href=&quot;#Has
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="集合" scheme="http://echoguan.coding.me/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java - 集合介绍(1) - Note</title>
    <link href="http://echoguan.coding.me/2018/11/13/Java-%E9%9B%86%E5%90%88%E4%BB%8B%E7%BB%8D-1/"/>
    <id>http://echoguan.coding.me/2018/11/13/Java-集合介绍-1/</id>
    <published>2018-11-13T06:59:05.000Z</published>
    <updated>2018-11-23T05:37:15.350Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://www.jianshu.com/p/589d58033841" target="_blank" rel="noopener">Ruheng - 由浅入深理解java集合(一)——集合框架 Collection、Map</a> </p></blockquote><h4 id="集合简介"><a href="#集合简介" class="headerlink" title="集合简介"></a>集合简介</h4><ul><li><strong>Java 集合</strong> 大致可分为<code>Set</code> , <code>List</code> , <code>Queue</code> , <code>Map</code> 四大体系。</li><li><strong>Set</strong> 代表 <strong>无序、不可重复</strong> 的集合。</li><li><strong>List</strong> 代表 <strong>有序、可重复</strong> 的集合。</li><li><strong>Map</strong> 代表具有 <strong>映射关系</strong> 的集合。</li><li><strong>Queue</strong> 代表 <strong>队列</strong> 集合。</li></ul><h4 id="Java-集合和数组的区别"><a href="#Java-集合和数组的区别" class="headerlink" title="Java 集合和数组的区别"></a>Java 集合和数组的区别</h4><ul><li><p><strong>长度</strong> </p><ul><li><strong>数组</strong> 的长度在初始化时指定，意味着只能存 <strong>定长</strong> 的数据。</li><li><strong>集合</strong> 可以保存 <strong>数量不确定</strong> 的数据。也可以保存具有<strong>映射关系</strong> 的数据( key - value )。</li></ul></li><li><p><strong>元素类型</strong> </p><ul><li><strong>数组</strong> 既可以保存基本类型的值，也可以保存对象。</li><li><strong>集合</strong> 只能保存对象（实际为对象的引用），基本类型必须转换成相应的封装类才可放入集合。</li></ul></li></ul><a id="more"></a><h4 id="集合类之间的继承关系"><a href="#集合类之间的继承关系" class="headerlink" title="集合类之间的继承关系"></a>集合类之间的继承关系</h4><ul><li><img src="/images/Collection.png" alt="Collection"> </li><li><img src="/images/Map.png" alt="Map"> </li></ul><h4 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h4><ul><li><p><code>Collection</code> 接口是<code>Set</code> , <code>Queue</code> , <code>List</code> 的父接口。</p></li><li><p><code>Collection</code> 接口中定义了多种数据操作的方法可供子类进行实现（以下为JDK10版本）。<a href="https://docs.oracle.com/javase/10/docs/api/java/util/Collection.html" target="_blank" rel="noopener">JDK Collection</a> </p></li></ul><table><thead><tr><th>Modifier and Type</th><th>Method</th><th>Desc</th></tr></thead><tbody><tr><td>Boolean</td><td>add(E e)</td><td>Ensures that this collection contains the specified element (optional operation).</td></tr><tr><td>boolean</td><td>addAll(Collection&lt;? extends E&gt; c)</td><td>Adds all of the elements in the specified collection to this collection (optional operation).</td></tr><tr><td>void</td><td>clear()</td><td>Removes all of the elements from this collection (optional operation).</td></tr><tr><td>boolean</td><td>contains(Object o)</td><td>Returns true if this collection contains the specified element.</td></tr><tr><td>boolean</td><td>containsAll(Collection&lt;?&gt; c)</td><td>Returns <code>true</code> if this collection contains all of the elements in the specified collection.</td></tr><tr><td>boolean</td><td>equals(Object o)</td><td>Compares the specified object with this collection for equality.</td></tr><tr><td>int</td><td>hashCode()</td><td>Returns the hash code value for this collection.</td></tr><tr><td>boolean</td><td>isEmpty()</td><td>Returns <code>true</code> if this collection contains no elements.</td></tr><tr><td>Iterator<e></e></td><td>iterator()</td><td>Returns an iterator over the elements in this collection.</td></tr><tr><td>default Stream<e></e></td><td>parallelStream()</td><td>Returns a possibly parallel <code>Stream</code> with this collection as its source.</td></tr><tr><td>boolean</td><td>remove(Object o)</td><td>Removes a single instance of the specified element from this collection, if it is present (optional operation).</td></tr><tr><td>boolean</td><td>removeAll(Collection&lt;?&gt; c)</td><td>Removes all of this collection’s elements that are also contained in the specified collection (optional operation).</td></tr><tr><td>default boolean</td><td>removeIf(Predicate&lt;? super E&gt; filter)</td><td>Removes all of the elements of this collection that satisfy the given predicate.</td></tr><tr><td>boolean</td><td>retainAll(Collection&lt;?&gt; c)</td><td>Retains only the elements in this collection that are contained in the specified collection (optional operation).</td></tr><tr><td>int</td><td>size()</td><td>Returns the number of elements in this collection.</td></tr><tr><td>default Spliterator<e></e></td><td>spliterator()</td><td>Creates a <a href="https://docs.oracle.com/javase/10/docs/api/java/util/Spliterator.html" target="_blank" rel="noopener"><code>Spliterator</code></a> over the elements in this collection.</td></tr><tr><td>default Stream<e></e></td><td>stream()</td><td>Returns a sequential <code>Stream</code> with this collection as its source.</td></tr><tr><td>Object[]</td><td>toArray()</td><td>Returns an array containing all of the elements in this collection.</td></tr><tr><td><t> T[]</t></td><td>toArray(T[] a)</td><td>Returns an array containing all of the elements in this collection; the runtime type of the returned array is that of the specified array.</td></tr></tbody></table><h4 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h4><ul><li><code>Set 集合</code> 与 <code>Collection 集合</code> 基本相同，没有提供额外的方法。</li><li>只是<code>Set</code> 行为略有不同，<strong>不允许包含重复元素</strong> 。</li><li>如果试图添加两个<strong>相同</strong> 的元素到同一个<code>Set集合</code> 中，则添加操作失败，<code>add()</code> 方法返回 <code>false</code> ，且新元素不会被加入。</li></ul><h4 id="List-集合"><a href="#List-集合" class="headerlink" title="List 集合"></a>List 集合</h4><ul><li><p><code>List 集合</code> ，<strong>元素有序、可重复</strong> 。集合中每个元素都有其对应的顺序索引。</p></li><li><p><code>List</code> <strong>允许使用重复</strong> 的元素。</p></li><li><p>可以通过索引来访问指定位置的集合元素。</p></li><li><p>默认按元素的添加顺序设置元素的索引。</p></li><li><p><code>List</code> 可以使用 <code>Collection</code> 接口里的所有方法。而且由于 List 为<strong>有序集合</strong> ，<strong>额外增加</strong> 了一些根据索引来操作集合元素的方法。</p></li></ul><table><thead><tr><th>Modifier and Type</th><th>Method</th><th>Desc</th></tr></thead><tbody><tr><td>void</td><td>add(int index, E element)</td><td>Inserts the specified element at the specified position in this list (optional operation).</td></tr><tr><td>boolean</td><td>addAll(int index, Collection&lt;? extends E&gt; c)</td><td>Inserts all of the elements in the specified collection into this list at the specified position (optional operation).</td></tr><tr><td>E</td><td>get(int index)</td><td>Returns the element at the specified position in this list.</td></tr><tr><td>int</td><td>indexOf(Object o)</td><td>Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element.</td></tr><tr><td>int</td><td>lastIndexOf(Object o)</td><td>Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element.</td></tr><tr><td>E</td><td>remove(int index)</td><td>Removes the element at the specified position in this list (optional operation).</td></tr><tr><td>E</td><td>set(int index, E element)</td><td>Replaces the element at the specified position in this list with the specified element (optional operation).</td></tr><tr><td>List<e></e></td><td>subList(int fromIndex, int toIndex)</td><td>Returns a view of the portion of this list between the specified <code>fromIndex</code>, inclusive, and <code>toIndex</code>, exclusive.</td></tr><tr><td>Object[]</td><td>toArray()</td><td>Returns an array containing all of the elements in this list in proper sequence (from first to last element).</td></tr><tr><td>default void</td><td>replaceAll(UnaryOperator<e> operator)</e></td><td>Replaces each element of this list with the result of applying the operator to that element.</td></tr><tr><td>default void</td><td>sort(Comparator&lt;? super E&gt; c)</td><td>Sorts this list according to the order induced by the specified <a href="https://docs.oracle.com/javase/10/docs/api/java/util/Comparator.html" target="_blank" rel="noopener"><code>Comparator</code></a>.</td></tr></tbody></table><h4 id="Queue-集合"><a href="#Queue-集合" class="headerlink" title="Queue 集合"></a>Queue 集合</h4><ul><li><code>队列</code> 数据结构。队列通常是指<strong>先进先出 FIFI</strong> 的容器。</li><li>通常，队列不允许随机访问队列中的元素。</li></ul><table><thead><tr><th>Modifier and Type</th><th>Method</th><th>Desc</th></tr></thead><tbody><tr><td>boolean</td><td>add(E e)</td><td>Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning <code>true</code> upon success and throwing an <code>IllegalStateException</code> if no space is currently available.</td></tr><tr><td>E</td><td>element()</td><td>Retrieves, but does not remove, the head of this queue.</td></tr><tr><td>boolean</td><td>offer(E e)</td><td>Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions.</td></tr><tr><td>E</td><td>peek()</td><td>Retrieves, but does not remove, the head of this queue, or returns <code>null</code> if this queue is empty.</td></tr><tr><td>E</td><td>poll()</td><td>Retrieves and removes the head of this queue, or returns <code>null</code> if this queue is empty.</td></tr><tr><td>E</td><td>remove()</td><td>Retrieves and removes the head of this queue.</td></tr></tbody></table><h4 id="Map-集合"><a href="#Map-集合" class="headerlink" title="Map 集合"></a>Map 集合</h4><ul><li><p><code>Map</code> 保存具有映射关系的数据。<code>key</code> 和 <code>value</code> 都可以是任何引用类型的数据。</p></li><li><p><code>key</code> <strong>不允许重复</strong> 。key 和 value 之间存在单向一对一关系。</p></li><li><p><code>Map</code> 与 <code>Set</code> <code>List</code> 的关系</p><ul><li><p>与<code>Set</code> 的关系：</p><ul><li>如果把<code>Map</code> 里的所有<code>key</code> 放在一起看，它们就组成了一个<code>Set</code> 集合（<code>key</code> 没有顺序，且不可重复）。</li><li>实际上<code>Map</code> 有一个 <code>keySet()</code> 方法，返回<code>Map</code> 里所有<code>key</code> 组成的<code>Set</code> 集合。</li></ul></li><li><p>与 <code>List</code> 的关系：</p><ul><li>如果把<code>Map</code> 里的所有<code>value</code> 放在一起看，它们又非常类似于一个 <code>List</code> （<code>value</code> 可重复，每个元素根据索引来查找）。</li></ul></li></ul></li><li><p><code>Map</code> 接口中定义的方法：</p></li></ul><table><thead><tr><th>Modifier and Type</th><th>Method</th><th>Desc</th></tr></thead><tbody><tr><td>void</td><td>clear()</td><td>Removes all of the mappings from this map (optional operation).</td></tr><tr><td>boolean</td><td>containsKey(Object key)</td><td>Returns <code>true</code> if this map contains a mapping for the specified key.</td></tr><tr><td>boolean</td><td>containsValue(Object value)</td><td>Returns <code>true</code> if this map maps one or more keys to the specified value.</td></tr><tr><td>Set&lt;Map.Entry&lt;K, V&gt;&gt;</td><td>entrySet()</td><td>Returns a <a href="https://docs.oracle.com/javase/10/docs/api/java/util/Set.html" target="_blank" rel="noopener"><code>Set</code></a> view of the mappings contained in this map.</td></tr><tr><td>boolean</td><td>equals(Object o)</td><td>Compares the specified object with this map for equality.</td></tr><tr><td>V</td><td>get(Object key)</td><td>Returns the value to which the specified key is mapped, or <code>null</code> if this map contains no mapping for the key.</td></tr><tr><td>int</td><td>hashCode()</td><td>Returns the hash code value for this map.</td></tr><tr><td>boolean</td><td>isEmpty()</td><td>Returns <code>true</code> if this map contains no key-value mappings.</td></tr><tr><td>Set<k></k></td><td>keySet()</td><td>Returns a <a href="https://docs.oracle.com/javase/10/docs/api/java/util/Set.html" target="_blank" rel="noopener"><code>Set</code></a> view of the keys contained in this map.</td></tr><tr><td>V</td><td>put(K key, V value)</td><td>Associates the specified value with the specified key in this map (optional operation).</td></tr><tr><td>void</td><td>putAll(Map&lt;? extends K, ? extends V&gt; m)</td><td>Copies all of the mappings from the specified map to this map (optional operation).</td></tr><tr><td>V</td><td>remove(Object key)</td><td>Removes the mapping for a key from this map if it is present (optional operation).</td></tr><tr><td>int</td><td>size()</td><td>Returns the number of key-value mappings in this map.</td></tr><tr><td>Collection<v></v></td><td>values()</td><td>Returns a <a href="https://docs.oracle.com/javase/10/docs/api/java/util/Collection.html" target="_blank" rel="noopener"><code>Collection</code></a> view of the values contained in this map.</td></tr></tbody></table><ul><li><code>Map</code> 还包含一个<strong>内部类</strong> <code>Entry</code> ，该类封装了一个<code>key-value</code> 对。</li></ul><table><thead><tr><th>Modifier and Type</th><th>Method</th><th>Desc</th></tr></thead><tbody><tr><td>boolean</td><td>equals(Object o)</td><td>Compares the specified object with this entry for equality.</td></tr><tr><td>K</td><td>getKey()</td><td>Returns the key corresponding to this entry.</td></tr><tr><td>V</td><td>getValue()</td><td>Returns the value corresponding to this entry.</td></tr><tr><td>int</td><td>hashCode()</td><td>Returns the hash code value for this map entry.</td></tr><tr><td>V</td><td>setValue(V value)</td><td>Replaces the value corresponding to this entry with the specified value (optional operation).</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/589d58033841&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ruheng - 由浅入深理解java集合(一)——集合框架 Collection、Map&lt;/a&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;集合简介&quot;&gt;&lt;a href=&quot;#集合简介&quot; class=&quot;headerlink&quot; title=&quot;集合简介&quot;&gt;&lt;/a&gt;集合简介&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Java 集合&lt;/strong&gt; 大致可分为&lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;List&lt;/code&gt; , &lt;code&gt;Queue&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; 四大体系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Set&lt;/strong&gt; 代表 &lt;strong&gt;无序、不可重复&lt;/strong&gt; 的集合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;List&lt;/strong&gt; 代表 &lt;strong&gt;有序、可重复&lt;/strong&gt; 的集合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Map&lt;/strong&gt; 代表具有 &lt;strong&gt;映射关系&lt;/strong&gt; 的集合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Queue&lt;/strong&gt; 代表 &lt;strong&gt;队列&lt;/strong&gt; 集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Java-集合和数组的区别&quot;&gt;&lt;a href=&quot;#Java-集合和数组的区别&quot; class=&quot;headerlink&quot; title=&quot;Java 集合和数组的区别&quot;&gt;&lt;/a&gt;Java 集合和数组的区别&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;长度&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数组&lt;/strong&gt; 的长度在初始化时指定，意味着只能存 &lt;strong&gt;定长&lt;/strong&gt; 的数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集合&lt;/strong&gt; 可以保存 &lt;strong&gt;数量不确定&lt;/strong&gt; 的数据。也可以保存具有&lt;strong&gt;映射关系&lt;/strong&gt; 的数据( key - value )。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;元素类型&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数组&lt;/strong&gt; 既可以保存基本类型的值，也可以保存对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集合&lt;/strong&gt; 只能保存对象（实际为对象的引用），基本类型必须转换成相应的封装类才可放入集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="集合" scheme="http://echoguan.coding.me/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Blog - hexo + yilia 博客访问量统计显示</title>
    <link href="http://echoguan.coding.me/2018/11/12/hexo-yilia-%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E9%87%8F%E7%BB%9F%E8%AE%A1%E6%98%BE%E7%A4%BA/"/>
    <id>http://echoguan.coding.me/2018/11/12/hexo-yilia-博客访问量统计显示/</id>
    <published>2018-11-12T07:06:18.000Z</published>
    <updated>2018-11-22T10:25:11.251Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-网站访问量显示"><a href="#1-网站访问量显示" class="headerlink" title="1. 网站访问量显示"></a>1. 网站访问量显示</h4><ul><li><p>效果</p><ul><li>见博客底部</li></ul></li><li><p>实现</p><ul><li><p>使用 <strong><a href="http://ibruce.info/" target="_blank" rel="noopener">不蒜子</a></strong> ，可以看官方介绍。</p></li><li><p>在 <code>themes/yilia/layout/_partial/footer.ejs</code> 中加入如下代码：</p></li><li><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 根据个人喜好在相应位置添加以下代码 --&gt;</div><div class="line">&lt;div calss=<span class="string">"count-span"</span>&gt;</div><div class="line">    &lt;span id=<span class="string">"busuanzi_container_site_pv"</span>&gt;</div><div class="line">    总访问量: <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>|</div><div class="line">    &lt;<span class="regexp">/span&gt;</span></div><div class="line"><span class="regexp">    &lt;span id="busuanzi_container_site_uv"&gt;</span></div><div class="line"><span class="regexp">    总访客: &lt;span id="busuanzi_value_site_uv"&gt;&lt;/</span>span&gt;</div><div class="line">    &lt;<span class="regexp">/span&gt;</span></div><div class="line"><span class="regexp">&lt;/</span>div&gt;</div><div class="line">&lt;!-- 根据个人喜好在相应位置添加以上代码 --&gt;</div><div class="line"></div><div class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></li><li><p>然后重新部署发布博客即可。</p></li></ul></li></ul><h4 id="2-网站-IP-访问量显示-友盟"><a href="#2-网站-IP-访问量显示-友盟" class="headerlink" title="2. 网站 IP 访问量显示(友盟)"></a>2. 网站 IP 访问量显示(友盟)</h4><ul><li><p>使用<a href="http://www.umeng.com/" target="_blank" rel="noopener">友盟</a> </p></li><li><p>首先注册一个帐号-&gt;进入个人中心-&gt;展开全部产品-&gt;选择<strong>U-Web网站统计</strong>-&gt;点击<strong>立即使用</strong>-&gt;<strong>添加站点</strong></p></li><li><p>然后在<code>站点设置</code> 里选择<code>获取代码</code> ，我这里选择的是 <code>横排数据显示</code> 。</p></li><li><p>然后把自己的代码加到 <code>footer.ejs</code> 中</p></li><li><p>可在<code>友盟</code>上查看最近的<strong>访问量</strong>和<strong>数据</strong> 。</p></li></ul><h4 id="3-文章访问量统计"><a href="#3-文章访问量统计" class="headerlink" title="3. 文章访问量统计"></a>3. 文章访问量统计</h4><ul><li>下面这段代码添加在<code>/themes/yilia/layout/_partial/article.ejs</code> 的header的日期后面：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 添加判断，如果首页则不显示访问量</div><div class="line">&lt;% if ( !index )&#123; %&gt;</div><div class="line">    &lt;span class=&quot;archive-article-date&quot;&gt;</div><div class="line">        阅读量 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;</div><div class="line">    &lt;/span&gt;</div><div class="line">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure><blockquote><p><a href="https://meetes.top/2018/01/31/Hexo%20+%20yilia%20%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%8F%AF%E8%83%BD%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%84%E6%89%80%E6%9C%89%E7%96%91%E9%97%AE/" target="_blank" rel="noopener">Hexo + yilia 搭建博客可能会遇到的所有疑问</a> </p><p><a href="http://www.lookk.cn/2017/12/09/hexo-yilia%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E8%AE%BF%E9%97%AE%E9%87%8F%E7%BB%9F%E8%AE%A1/" target="_blank" rel="noopener">hexo yilia主题添加文章访问量统计</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-网站访问量显示&quot;&gt;&lt;a href=&quot;#1-网站访问量显示&quot; class=&quot;headerlink&quot; title=&quot;1. 网站访问量显示&quot;&gt;&lt;/a&gt;1. 网站访问量显示&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;效果&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;见博客底部&lt;/li&gt;
&lt;/ul
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="hexo" scheme="http://echoguan.coding.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java - 枚举类型介绍总结</title>
    <link href="http://echoguan.coding.me/2018/10/14/Java-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D%E6%80%BB%E7%BB%93/"/>
    <id>http://echoguan.coding.me/2018/10/14/Java-枚举类型介绍总结/</id>
    <published>2018-10-14T13:18:14.000Z</published>
    <updated>2018-11-22T02:58:38.283Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>枚举类型（<code>enum type</code>）是指由一组固定的常量组成合法的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season &#123;</div><div class="line">    SPRING, SUMMER, AUTUMN, WINTER;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>特点：</p><ul><li>使用关键字<code>enum</code> </li><li>类型名称，如<code>Season</code> </li><li>一串允许的值（<code>SPRING, SUMMER, AUTUMN, WINTER</code>）</li><li>枚举可以单独定义在一个文件中，也可以嵌在其它 <code>Java类</code> 中。</li><li><code>枚举类型</code> 可以实现一个或多个接口</li><li>可以定义新的变量</li><li>可以定义新的方法</li><li>可以定义根据具体枚举值而相异的类</li></ul></li><li><p>应用举例：</p><blockquote><p><a href="http://www.hollischuang.com/archives/195" target="_blank" rel="noopener">Hollis - Java的枚举类型用法介绍</a> </p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;枚举类型（&lt;code&gt;enum type&lt;/code&gt;）是指由一组固定的常量组成合法的类型。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Interview" scheme="http://echoguan.coding.me/tags/Interview/"/>
    
      <category term="枚举类型" scheme="http://echoguan.coding.me/tags/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android - Ramp Up 笔记</title>
    <link href="http://echoguan.coding.me/2018/09/11/Android-Ramp-Up-Memo/"/>
    <id>http://echoguan.coding.me/2018/09/11/Android-Ramp-Up-Memo/</id>
    <published>2018-09-11T02:40:21.000Z</published>
    <updated>2018-11-22T02:58:38.263Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><ul><li><strong>Acceptance Criteria</strong> </li><li>MVP, Dagger2, Retrofit, RxJava, Unit test</li></ul><h4 id="MVP-Pattern"><a href="#MVP-Pattern" class="headerlink" title="MVP Pattern"></a>MVP Pattern</h4><ul><li><p>Model-View-Presenter</p></li><li><p>是由 <code>MVC</code> 演变而来。在 <code>MVP</code> 中：</p><ul><li><code>View</code> 更加专注于处理数据可视化和页面交互</li><li><code>Model</code> 更加专注于数据的处理</li><li><code>Presenter</code> 则提供 <code>View</code> 和 <code>Model</code> 之间数据的纽带，用于交互和数据传输</li></ul></li><li><p><strong><code>View</code>不直接与<code>Model</code>交互</strong> </p></li><li><h4 id="MVP-in-four-bullet-points"><a href="#MVP-in-four-bullet-points" class="headerlink" title="MVP in four bullet points"></a>MVP in four bullet points</h4><ul><li>MVP stands for Model-View-Presenter.</li><li>The “Model” is your data source, doesn’t matter if a database, network calls or a hard-coded list of objects.</li><li>The “View” is your Activity, Fragment or custom Android View. Which should just take care of displaying things and handling user interaction.</li><li>The “Presenter” is a plain old java object (POJO) that handles the communication between the View and the Model, makes any required data transformations, handles errors from the Model and tries to remove as much UX logic from the View as possible.</li></ul></li></ul><blockquote><p><a href="https://blog.csdn.net/u011418943/article/details/69840880" target="_blank" rel="noopener">MVP 设计模式理解，实战理解MVP</a> </p><p><a href="https://www.jianshu.com/p/9a6845b26856" target="_blank" rel="noopener">Android MVP 详解（上）</a> </p></blockquote><a id="more"></a><h4 id="RxJava-RxAndroid"><a href="#RxJava-RxAndroid" class="headerlink" title="RxJava/RxAndroid"></a>RxJava/RxAndroid</h4><ul><li><p><code>RxJava</code> 的本质可以压缩为<strong>异步</strong>这一个词。说到根上，它就是一个实现异步操作的库，而别的定语都是基于这之上的。</p></li><li><p>优势：<strong>简洁</strong></p></li><li><p><code>RxJava</code> 的异步实现，是通过一种扩展的<strong>观察者模式</strong>来实现的。</p></li><li><p><code>RxJava</code> 有四个基本概念：<strong>Observable</strong> (可观察者，即被观察者)、 <strong>Observer</strong> (观察者)、<strong>subscribe</strong> (订阅)、<strong>事件</strong>。</p></li><li><p><code>RxJava</code> 的观察者模式大致如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2405826-1b43cf8a80bfca3f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/599/format/webp" alt="img"></p></li></ul><blockquote><p><a href="https://www.jianshu.com/p/10d4d7c69345" target="_blank" rel="noopener">Rxjava、RxAndroid系列</a></p></blockquote><h4 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h4><ul><li><code>Retrofit</code> 是 Square 的一个著名的<strong>网络请求库</strong>。</li><li><code>Retrofit</code> 除了提供了传统的 Callback 形式的 <code>API</code>，还有 <code>RxJava</code> 版本的 Observable 形式 <code>API</code>。</li></ul><h4 id="Robolectric"><a href="#Robolectric" class="headerlink" title="Robolectric"></a>Robolectric</h4><ul><li><code>gradlew clean build</code></li></ul><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><ul><li><p>构成应用的组件主要有四种：<code>Activities</code>活动、<code>Services</code> 服务、<code>Broadcast Receivers</code> 广播接收器 和 <code>Content Providers</code> 内容提供者。</p></li><li><p><code>Android Manifest</code> 用于向 Android 框架<strong>注册组件</strong>。</p></li><li><p><code>Activity</code>：Single focused thing that the user can do.(用户可以执行的单一任务)</p><ul><li><p>负责<strong>显示应用用户界面</strong>。</p></li><li><p><code>Activity</code> 通过读取 <code>XML布局文件</code> 确定要创建哪些视图（并放在何处）。</p></li><li><blockquote><p><a href="https://classroom.udacity.com/courses/ud851/lessons/93affc67-3f0b-4f9b-b3a4-a7a26f241a86/concepts/cdbfd437-de24-4903-8f01-37c29427cb38#" target="_blank" rel="noopener">Android 布局入门</a></p></blockquote></li></ul></li><li><p><code>Layout</code> </p><ul><li>分为三种：<code>FrameLayout</code> 帧布局、 <code>LinearLayout</code> 线性布局、 <code>ConstraintLayout</code> 约束布局</li></ul></li><li><p><code>AsyncTask</code> : 在 Android <strong>线程之间</strong>进行线程和消息<strong>传递</strong>的有用抽象类。</p></li><li><p>Tips: </p><ul><li><code>Android</code> 特殊的<strong>日志</strong>级别：<code>WTF(What a Terrible Failure)</code> &gt; <code>ERROR</code> </li><li><code>Json</code> : <strong>Java Script Object Notation</strong> </li></ul></li><li><p>设置</p><ul><li>proxy</li><li>Gradle -&gt; offline work 选上</li><li>Compiler -&gt; Configure on demand 不选</li></ul></li></ul><h4 id="大坑"><a href="#大坑" class="headerlink" title="大坑"></a>大坑</h4><h5 id="Android-Studio-Gradle-Sync-Failed-错误"><a href="#Android-Studio-Gradle-Sync-Failed-错误" class="headerlink" title="Android Studio Gradle Sync Failed 错误"></a>Android Studio <code>Gradle Sync Failed</code> 错误</h5><ul><li><p>出现错误的原因：<strong>Android Studio 需要设置代理 FQ</strong></p><ul><li><p><code>settings</code> 搜索 <code>proxy</code> </p></li><li><p>我是用 ShadowSocks ，设置如下图：</p><p><img src="/images/AndroidStudioProxy.png" alt="Proxy Setting"> </p></li></ul><blockquote><p><a href="https://blog.csdn.net/lchad/article/details/43567675" target="_blank" rel="noopener">【Android】给Android Studio设置代理</a> </p></blockquote></li></ul><h4 id="ButterKnife"><a href="#ButterKnife" class="headerlink" title="ButterKnife"></a>ButterKnife</h4><ul><li><p><strong>ButterKnife</strong> 是一个 <code>Android</code> 系统的 <code>View</code> 注入框架，能够通过『注解』的方式来绑定 <code>View</code> 的属性或方法。</p></li><li><p>比如使用它能够减少 <code>findViewById()</code> 的书写，使代码更为简洁明了，同时不消耗额外的性能。</p><blockquote><p><a href="https://www.jianshu.com/p/1d80c7dd01ba" target="_blank" rel="noopener">[Android] ButterKnife 浅析</a> </p><p><a href="https://www.jianshu.com/p/952c6f5e8157" target="_blank" rel="noopener">https://www.jianshu.com/p/952c6f5e8157</a> </p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Demo&quot;&gt;&lt;a href=&quot;#Demo&quot; class=&quot;headerlink&quot; title=&quot;Demo&quot;&gt;&lt;/a&gt;Demo&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Acceptance Criteria&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;MVP, Dagger2, Retrofit, RxJava, Unit test&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;MVP-Pattern&quot;&gt;&lt;a href=&quot;#MVP-Pattern&quot; class=&quot;headerlink&quot; title=&quot;MVP Pattern&quot;&gt;&lt;/a&gt;MVP Pattern&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Model-View-Presenter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;是由 &lt;code&gt;MVC&lt;/code&gt; 演变而来。在 &lt;code&gt;MVP&lt;/code&gt; 中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;View&lt;/code&gt; 更加专注于处理数据可视化和页面交互&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Model&lt;/code&gt; 更加专注于数据的处理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Presenter&lt;/code&gt; 则提供 &lt;code&gt;View&lt;/code&gt; 和 &lt;code&gt;Model&lt;/code&gt; 之间数据的纽带，用于交互和数据传输&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;View&lt;/code&gt;不直接与&lt;code&gt;Model&lt;/code&gt;交互&lt;/strong&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h4 id=&quot;MVP-in-four-bullet-points&quot;&gt;&lt;a href=&quot;#MVP-in-four-bullet-points&quot; class=&quot;headerlink&quot; title=&quot;MVP in four bullet points&quot;&gt;&lt;/a&gt;MVP in four bullet points&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;MVP stands for Model-View-Presenter.&lt;/li&gt;
&lt;li&gt;The “Model” is your data source, doesn’t matter if a database, network calls or a hard-coded list of objects.&lt;/li&gt;
&lt;li&gt;The “View” is your Activity, Fragment or custom Android View. Which should just take care of displaying things and handling user interaction.&lt;/li&gt;
&lt;li&gt;The “Presenter” is a plain old java object (POJO) that handles the communication between the View and the Model, makes any required data transformations, handles errors from the Model and tries to remove as much UX logic from the View as possible.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u011418943/article/details/69840880&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MVP 设计模式理解，实战理解MVP&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/9a6845b26856&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android MVP 详解（上）&lt;/a&gt; &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Android" scheme="http://echoguan.coding.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java - JDK, JRE, JVM简介</title>
    <link href="http://echoguan.coding.me/2018/09/09/JDK-JRE-JVM%E7%AE%80%E4%BB%8B/"/>
    <id>http://echoguan.coding.me/2018/09/09/JDK-JRE-JVM简介/</id>
    <published>2018-09-09T06:01:59.000Z</published>
    <updated>2018-11-22T02:58:38.280Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JDK-Java-Development-ToolKit-Java-开发工具包"><a href="#JDK-Java-Development-ToolKit-Java-开发工具包" class="headerlink" title="JDK(Java Development ToolKit) - Java 开发工具包"></a>JDK(Java Development ToolKit) - Java 开发工具包</h4><ul><li><code>JDK</code> 是整个 Java 的<strong>核心</strong>。</li><li>包括：<ul><li><strong>JRE</strong> - Java 运行环境</li><li><strong>Java API</strong> - Java 基础的<strong>类库</strong> </li><li>一堆<code>Java 工具</code>（javac/java/jdb等）</li></ul></li></ul><h4 id="JRE-Java-Runtime-Environment-Java-运行时环境"><a href="#JRE-Java-Runtime-Environment-Java-运行时环境" class="headerlink" title="JRE(Java Runtime Environment) - Java 运行时环境"></a>JRE(Java Runtime Environment) - Java 运行时环境</h4><ul><li><p>所有的 Java 程序都必须在 <code>JRE</code> 下才能<strong>运行</strong>。</p></li><li><p>包括：</p><ul><li>JVM</li><li>Java 核心类库</li><li>支持文件</li></ul></li></ul><h4 id="JVM-Java-Virtual-Mechinal-Java-虚拟机"><a href="#JVM-Java-Virtual-Mechinal-Java-虚拟机" class="headerlink" title="JVM(Java Virtual Mechinal) - Java 虚拟机"></a>JVM(Java Virtual Mechinal) - Java 虚拟机</h4><ul><li><code>JVM</code> 是 <code>JRE</code> 的一部分。</li><li>它是一个虚构出来的计算机。</li><li><code>JVM</code> 有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。</li><li><code>JVM</code> 的主要工作是，解释自己的编码集，并映射到本地 CPU 的指令集或 OS 的系统调用。</li><li>Java 语言的跨平台特性，其实就是不同的操作系统，使用不同的 JVM 映射规则。</li></ul><p><img src="/images/JDKJREJVM-relation.gif" alt="JDK JRE JVM 关系"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;JDK-Java-Development-ToolKit-Java-开发工具包&quot;&gt;&lt;a href=&quot;#JDK-Java-Development-ToolKit-Java-开发工具包&quot; class=&quot;headerlink&quot; title=&quot;JDK(Java Devel
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JDK" scheme="http://echoguan.coding.me/tags/JDK/"/>
    
      <category term="JRE" scheme="http://echoguan.coding.me/tags/JRE/"/>
    
      <category term="JVM" scheme="http://echoguan.coding.me/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Spring - 深入理解 Spring IoC</title>
    <link href="http://echoguan.coding.me/2018/08/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Spring-IoC/"/>
    <id>http://echoguan.coding.me/2018/08/05/深入理解-Spring-IoC/</id>
    <published>2018-08-05T08:38:00.000Z</published>
    <updated>2018-11-22T02:58:38.328Z</updated>
    
    <content type="html"><![CDATA[<h4 id="IOC-理论"><a href="#IOC-理论" class="headerlink" title="IOC 理论"></a>IOC 理论</h4><ul><li>IoC 全称为 <code>InversionofControl</code>，翻译为 “控制反转”，它还有一个别名为 DI（ <code>DependencyInjection</code>），即依赖注入。</li><li><strong>所谓 IOC ，就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系。</strong></li><li>IoC 的理念就是<strong>让别人为你服务。</strong></li></ul><ol><li><strong>谁控制谁</strong>：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IOC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。</li><li><strong>控制什么</strong>：控制对象。</li><li><strong>为何是反转</strong>：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。</li><li><strong>哪些方面反转了</strong>：所依赖对象的获取被反转了。</li></ol><ul><li>IOC Service Provider 为被注入对象提供被依赖对象也有如下几种方式：<strong>构造器注入</strong>、<strong>setter 注入</strong>、<strong>接口注入</strong>。</li></ul><blockquote><p><a href="https://mp.weixin.qq.com/s/nCvZ9NbNQeD_FtJyho4owg" target="_blank" rel="noopener">【死磕 Spring】—– IOC 之深入理解 Spring IoC</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;IOC-理论&quot;&gt;&lt;a href=&quot;#IOC-理论&quot; class=&quot;headerlink&quot; title=&quot;IOC 理论&quot;&gt;&lt;/a&gt;IOC 理论&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;IoC 全称为 &lt;code&gt;InversionofControl&lt;/code&gt;，翻译为 “控制反
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Spring" scheme="http://echoguan.coding.me/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>备忘 - IntelliJ IDEA 配置 备忘录</title>
    <link href="http://echoguan.coding.me/2018/07/04/IntelliJ-IDEA-Config-Memo/"/>
    <id>http://echoguan.coding.me/2018/07/04/IntelliJ-IDEA-Config-Memo/</id>
    <published>2018-07-04T13:02:02.000Z</published>
    <updated>2018-11-22T02:58:38.274Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-配置JDK"><a href="#1-配置JDK" class="headerlink" title="1. 配置JDK"></a>1. 配置JDK</h4><h4 id="2-常用设置"><a href="#2-常用设置" class="headerlink" title="2. 常用设置"></a>2. 常用设置</h4><ul><li><p>Theme: Relax Your Eyes Green</p></li><li><p>代码补全取消区分大小写</p><p>Preferences -&gt; 搜索 code completion -&gt; Case sensitive completion 选为 none。</p></li><li><p>自动导包</p></li></ul><p><img src="http://img.phperz.com/data/img/20150923/1443020024_1689.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-配置JDK&quot;&gt;&lt;a href=&quot;#1-配置JDK&quot; class=&quot;headerlink&quot; title=&quot;1. 配置JDK&quot;&gt;&lt;/a&gt;1. 配置JDK&lt;/h4&gt;&lt;h4 id=&quot;2-常用设置&quot;&gt;&lt;a href=&quot;#2-常用设置&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="工具" scheme="http://echoguan.coding.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="JDK" scheme="http://echoguan.coding.me/tags/JDK/"/>
    
      <category term="备忘" scheme="http://echoguan.coding.me/tags/%E5%A4%87%E5%BF%98/"/>
    
  </entry>
  
  <entry>
    <title>备忘 - Mackbook 新装机</title>
    <link href="http://echoguan.coding.me/2018/07/04/Mackbook-Install-Memo/"/>
    <id>http://echoguan.coding.me/2018/07/04/Mackbook-Install-Memo/</id>
    <published>2018-07-04T05:52:19.000Z</published>
    <updated>2018-11-22T02:58:38.295Z</updated>
    
    <content type="html"><![CDATA[<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol><li>Chrome</li><li>Lantern</li><li>搜狗输入法</li><li>TeamViewer</li><li>有道翻译</li><li>百度云</li><li>QQ</li><li>WeChat</li><li>Parallels Desktop</li><li>Office</li><li>IINA</li></ol><h3 id="Develop-Tools"><a href="#Develop-Tools" class="headerlink" title="Develop Tools"></a>Develop Tools</h3><ol><li>Typora</li><li>iTerm2<ol><li>配色：</li></ol></li><li>VSCode<ol><li>插件：ESlint, Prettier, Auto Close Tag, VSCode Great Icons</li></ol></li><li>GitHub Desktop</li><li>IntelliJ IDEA</li></ol><h3 id="Utils"><a href="#Utils" class="headerlink" title="Utils"></a>Utils</h3><ol><li>Git </li><li>Node</li><li>homebrew</li><li>wget</li><li>Maven</li><li>Java</li><li>MongoDB</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;应用&quot;&gt;&lt;a href=&quot;#应用&quot; class=&quot;headerlink&quot; title=&quot;应用&quot;&gt;&lt;/a&gt;应用&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Chrome&lt;/li&gt;
&lt;li&gt;Lantern&lt;/li&gt;
&lt;li&gt;搜狗输入法&lt;/li&gt;
&lt;li&gt;TeamViewer&lt;/li&gt;

      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="备忘" scheme="http://echoguan.coding.me/tags/%E5%A4%87%E5%BF%98/"/>
    
      <category term="MacBook" scheme="http://echoguan.coding.me/tags/MacBook/"/>
    
  </entry>
  
  <entry>
    <title>备忘 - iTerm2 配色方案</title>
    <link href="http://echoguan.coding.me/2018/07/04/iTerm2-Color-Schemes/"/>
    <id>http://echoguan.coding.me/2018/07/04/iTerm2-Color-Schemes/</id>
    <published>2018-07-04T00:46:01.000Z</published>
    <updated>2018-11-22T02:58:38.310Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录自己配置过程</p></blockquote><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="/images/itrem2-theme-echo.png" alt="iterm2"> </p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><a id="more"></a><ol><li>设置 iTerm2 为<strong>默认终端</strong>：<ul><li>（菜单栏）iTerm2 -&gt; Make iTerm2 Default Term </li></ul></li><li>全局热键启动和关闭 iTerm2：<ul><li>偏好设置 preferences -&gt; Keys -&gt; 勾选 Hotkey 下的 Show/hide iTerm2 with a system-wide hotkey，将热键设置为command+i</li></ul></li><li>Mac OS X 上修改主机名：<code>sudo scutil --set HostName MacBookPro</code></li><li>透明度：偏好设置 preferences -&gt; Profiles，右侧找到window选项卡，拖动Transparency调整。</li></ol><h4 id="配色方案"><a href="#配色方案" class="headerlink" title="配色方案"></a>配色方案</h4><ul><li>我选用的是 <a href="http://ethanschoonover.com/solarized" target="_blank" rel="noopener">solarized</a>，点开官网，下载，解压。</li><li>然后打开 iTerm2 下的偏好设置 preference ，点开 profiles 下的 colors 选项，点击右下角的 Color Presets  选项，选择 import ，导入解压到的 solarized 文件下的 Solarized Dark.itermcolors。</li><li>然后勾选 Solarized Dark。</li></ul><h4 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh-my-zsh"></a>安装 <a href="http://ohmyz.sh/" target="_blank" rel="noopener">oh-my-zsh</a></h4><ol><li>命令行输入 <code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></li><li><code>nano ~/.zshrc</code>，修改为 <code>ZSH_THEME=&quot;ys&quot;</code></li></ol><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><ol><li><a href="https://link.jianshu.com/?t=http://mimosa-pudica.net/zsh-incremental.html" target="_blank" rel="noopener">incr.zsh</a> 自动补齐插件 - 不好用，无法粘贴命令</li><li>highlight 插件</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录自己配置过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效果图&quot; class=&quot;headerlink&quot; title=&quot;效果图&quot;&gt;&lt;/a&gt;效果图&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/itrem2-theme-echo.png&quot; alt=&quot;iterm2&quot;&gt; &lt;/p&gt;
&lt;h4 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h4&gt;
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="工具" scheme="http://echoguan.coding.me/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="备忘" scheme="http://echoguan.coding.me/tags/%E5%A4%87%E5%BF%98/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 - Facade 外观模式/门面模式</title>
    <link href="http://echoguan.coding.me/2018/06/29/Facade-Pattern/"/>
    <id>http://echoguan.coding.me/2018/06/29/Facade-Pattern/</id>
    <published>2018-06-29T02:18:08.000Z</published>
    <updated>2018-11-22T02:58:38.265Z</updated>
    
    <content type="html"><![CDATA[<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li><p>The intent of the Facade is to provide a high-level interface (properties and methods) that makes a subsystem or toolkit easy to use for the client. </p><p>统一入口，简化调用</p></li><li><p>The Facade exposes only what is necessary and presents a cleaner and easy-to-use interface. </p><p>降低依赖，松耦合</p></li></ul><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ul><li>It is often present in systems that are built around a multi-layer architecture. </li><li>Facades themselves are often implemented as singleton factories. </li></ul><h5 id="Diagram"><a href="#Diagram" class="headerlink" title="Diagram"></a>Diagram</h5><p><img src="https://www.dofactory.com/images/diagrams/javascript/javascript-facade.jpg" alt="Diagram JavaScript Facade  Design Pattern"> </p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><blockquote><p><a href="https://www.dofactory.com/javascript/facade-design-pattern" target="_blank" rel="noopener">facade-design-pattern</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The intent of the Facade is to provide a high-level interface
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="设计模式" scheme="http://echoguan.coding.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java - 基本数据类型和引用数据类型</title>
    <link href="http://echoguan.coding.me/2018/04/04/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://echoguan.coding.me/2018/04/04/Java基本数据类型和引用数据类型/</id>
    <published>2018-04-04T09:59:31.000Z</published>
    <updated>2018-11-22T02:58:38.289Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/dubo-/p/5565677.html" target="_blank" rel="noopener">https://www.cnblogs.com/dubo-/p/5565677.html</a><br><a href="https://blog.csdn.net/coding_zhu/article/details/53096178" target="_blank" rel="noopener">https://blog.csdn.net/coding_zhu/article/details/53096178</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dubo-/p/5565677.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/dubo-/p/5565677.html&lt;/a&gt;&lt;br
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>React - 组件的生命周期 - Note(3)</title>
    <link href="http://echoguan.coding.me/2018/04/03/React%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://echoguan.coding.me/2018/04/03/React组件的生命周期/</id>
    <published>2018-04-03T09:23:10.000Z</published>
    <updated>2018-11-22T02:58:38.304Z</updated>
    
    <content type="html"><![CDATA[<ul><li>为了理解<code>React</code>的工作过程，我们必须要了解<code>React</code>组件的<strong>生命周期</strong>。</li><li>生命周期可能会经历如下三个过程：<ul><li>装载过程（<code>Mount</code>），也就是把组件第一次在<code>DOM树</code>中渲染的过程。</li><li>更新过程（<code>Update</code>），当组件被重新渲染的过程。</li><li>卸载过程（<code>Unmount</code>），组件从<code>DOM</code>中删除的过程。</li></ul></li><li>三个不同的过程中，React库会依次调用组件的一些成员函数，这些函数叫做<strong>生命周期函数</strong>。</li><li>定制一个React组件，实际上就是定制这些生命周期函数。</li></ul><h4 id="装载过程"><a href="#装载过程" class="headerlink" title="装载过程"></a>装载过程</h4><ul><li>当组件第一次被渲染的时候，依次调用的函数如下：<ul><li><code>constructor</code></li><li><code>getInitialState</code></li><li><code>getDefaultProps</code></li><li><code>componentWillMount</code></li><li><code>render</code></li><li><code>componentDidMount</code></li></ul></li></ul><a id="more"></a><h5 id="1-constructor"><a href="#1-constructor" class="headerlink" title="1. constructor"></a>1. constructor</h5><ul><li><code>constructor</code>也就是ES6中每个类的构造函数</li><li>但并不是每个组件都需要定义自己的构造函数。无状态的<code>React组件</code>往往就不需要定义构造函数。</li><li>一个组件需要构造函数，往往是为了以下的目的：<ul><li><strong>初始化<code>state</code></strong>。因为组件生命周期中任何函数都可能要访问<code>state</code>，那么整个生命周期中第一个被调用的构造函数自然是初始化<code>state</code>最理想的地方。</li><li><strong>绑定成员函数的<code>this</code>环境</strong>。</li></ul></li></ul><h5 id="2-getInitialState-和-getDefaultProps"><a href="#2-getInitialState-和-getDefaultProps" class="headerlink" title="2. getInitialState 和 getDefaultProps"></a>2. getInitialState 和 getDefaultProps</h5><ul><li>这两个方法都只有用<code>React.createClass</code>方法创造的组件类才会发生作用。<strong>使用<code>ES6</code>语法时，这两个函数根本不会产生作用</strong>。<ul><li><code>getInitialState</code>函数的返回值会用来初始化组件的<code>this.state</code>。</li><li><code>getDefaultProps</code>函数的返回值可以作为<code>props</code>的初始值。</li></ul></li><li>在<code>ES6</code>中，在构造函数中通过给<code>this.state</code>赋值完成状态的初始化；通过给类属性<code>defaultProps</code>赋值指定<code>props</code>的初始值，达到的效果是完全一样的。</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">  constructor(props)&#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.state = &#123;foo : <span class="symbol">'ba</span>r'&#125;;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="type">Sample</span>.defaultProps = &#123;</div><div class="line">  sampleProp: <span class="number">0</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li><code>React.createClass</code>已经被Facebook官方逐渐废弃，不建议使用。</li></ul><h5 id="3-render"><a href="#3-render" class="headerlink" title="3. render"></a>3. render</h5><ul><li><code>render</code>函数无疑是<code>React组件</code>中最重要的函数。<ul><li>一个组件可以忽略其他所有函数都不实现，但是一定要实现<code>render函数</code>。</li><li>因为所有React组件的父类<code>React.Component类</code>对除<code>render</code>之外的生命周期函数都有默认实现。</li></ul></li><li><code>render</code>函数并不做实际的渲染动作，它只是返回一个<code>JSX</code>描述的结构，最终由<code>React</code>来操作渲染过程。</li><li>如果某些特殊组件的作用不是渲染界面，或者，在某些情况下选择没有东西可画，那就让<code>render</code>函数返回一个<code>null</code>或者<code>false</code>，告诉<code>React</code>，该组件这次不需要渲染任何<code>DOM元素</code>。</li><li><code>render函数</code>应该是一个<strong>纯函数</strong>。在<code>render</code>中调用<code>this.setState</code>毫无疑问是错误的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;为了理解&lt;code&gt;React&lt;/code&gt;的工作过程，我们必须要了解&lt;code&gt;React&lt;/code&gt;组件的&lt;strong&gt;生命周期&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;生命周期可能会经历如下三个过程：&lt;ul&gt;
&lt;li&gt;装载过程（&lt;code&gt;Mount&lt;/code&gt;），也就是把组件第一次在&lt;code&gt;DOM树&lt;/code&gt;中渲染的过程。&lt;/li&gt;
&lt;li&gt;更新过程（&lt;code&gt;Update&lt;/code&gt;），当组件被重新渲染的过程。&lt;/li&gt;
&lt;li&gt;卸载过程（&lt;code&gt;Unmount&lt;/code&gt;），组件从&lt;code&gt;DOM&lt;/code&gt;中删除的过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;三个不同的过程中，React库会依次调用组件的一些成员函数，这些函数叫做&lt;strong&gt;生命周期函数&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;定制一个React组件，实际上就是定制这些生命周期函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;装载过程&quot;&gt;&lt;a href=&quot;#装载过程&quot; class=&quot;headerlink&quot; title=&quot;装载过程&quot;&gt;&lt;/a&gt;装载过程&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;当组件第一次被渲染的时候，依次调用的函数如下：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;constructor&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getInitialState&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getDefaultProps&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;componentWillMount&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;render&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;componentDidMount&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="笔记" scheme="http://echoguan.coding.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="React" scheme="http://echoguan.coding.me/tags/React/"/>
    
      <category term="《深入浅出React和Redux》" scheme="http://echoguan.coding.me/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAReact%E5%92%8CRedux%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>备忘 - Git Memo</title>
    <link href="http://echoguan.coding.me/2018/04/02/Git-Memo/"/>
    <id>http://echoguan.coding.me/2018/04/02/Git-Memo/</id>
    <published>2018-04-02T03:05:33.000Z</published>
    <updated>2018-11-22T02:58:38.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git-提交"><a href="#git-提交" class="headerlink" title="git 提交"></a>git 提交</h2><ul><li><code>git pull</code> 同步代码到本地</li><li><code>git status</code> 查看代码的修改状态</li><li><code>git diff</code> 查看本地修改</li><li><code>git add &lt;file&gt;</code> 暂存需要提交的文件<ul><li><code>git add .</code> 暂存所有修改的文件</li></ul></li><li><code>git commit -m &quot;commit comment&quot;</code> 提交已暂存的文件</li><li><code>git push</code> 同步到服务器<ul><li><code>git push origin &lt;本地分支名&gt;</code> </li></ul></li></ul><h2 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h2><ul><li><code>git stash</code>可以用来暂存当前正在进行中的工作。<ul><li>比如想<code>pull</code>新的代码，但暂时不想加新的<code>commit</code></li><li>比如为了 fix 一个紧急的 bug，先<code>stash</code>，回到上一个<code>commit</code>的代码，改完之后再<code>git stash pop</code>，继续原来的工作。</li></ul></li><li>常用命令：<ul><li><code>git stash</code> - save uncommitted changes<ul><li><code>git stash save &quot;work in progress for A feature&quot;</code></li></ul></li><li><code>git stash pop</code> - apply last stash and remove it from the list<ul><li><code>git stash apply stash@{1}</code></li></ul></li><li><code>git stash list</code> - list stashed changes in this git</li><li><code>git stash --help</code></li><li><code>git show stash@{0}</code> - show the last stash</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;git-提交&quot;&gt;&lt;a href=&quot;#git-提交&quot; class=&quot;headerlink&quot; title=&quot;git 提交&quot;&gt;&lt;/a&gt;git 提交&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git pull&lt;/code&gt; 同步代码到本地&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="git" scheme="http://echoguan.coding.me/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Java - 数组声明与初始化</title>
    <link href="http://echoguan.coding.me/2018/03/27/Java%E6%95%B0%E7%BB%84%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://echoguan.coding.me/2018/03/27/Java数组声明与初始化/</id>
    <published>2018-03-27T06:30:32.000Z</published>
    <updated>2018-11-22T02:58:38.291Z</updated>
    
    <content type="html"><![CDATA[<h5 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h5><ul><li>格式： <code>数据类型 + [] + 数组名称</code>，例如<code>int[] a</code>。</li></ul><h5 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h5><h6 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h6><ul><li>静态初始化：不用<code>new</code>关键字，在数组声明的同时完成初始化操作。</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</div><div class="line"></div><div class="line">Integer[] b = &#123;</div><div class="line">  new Integer(<span class="number">1</span>),</div><div class="line">  new Integer(<span class="number">2</span>),</div><div class="line">  <span class="number">3</span>               <span class="comment">//Autoboxing</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><h6 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h6><ul><li>先使用<code>new</code>关键字创建数组。<ul><li>在完成<code>new</code>操作之后，<strong>数组中的元素会自动初始化为空值</strong>（例如<code>int</code>，会被自动初始化为<code>0</code>；<code>String</code>会被自动自动初始化为<code>null</code>）。</li></ul></li><li>然后再分别为数组中的元素赋值，完成初始化操作。</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int[] a = new int[<span class="number">2</span>];</div><div class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">a[<span class="number">1</span>] = <span class="number">2</span>;</div></pre></td></tr></table></figure><h6 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h6><ul><li>使用<code>new</code>关键字创建数组，同时为数组的元素赋值，完成初始化操作。</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int[] a = <span class="keyword">new</span> <span class="type">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</div><div class="line"></div><div class="line">Integer[] b = <span class="keyword">new</span> <span class="type">Integer</span>[] &#123;</div><div class="line">  <span class="keyword">new</span> <span class="type">Integer</span>(<span class="number">1</span>),</div><div class="line">  <span class="keyword">new</span> <span class="type">Integer</span>(<span class="number">2</span>),</div><div class="line">  <span class="number">3</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;数组声明&quot;&gt;&lt;a href=&quot;#数组声明&quot; class=&quot;headerlink&quot; title=&quot;数组声明&quot;&gt;&lt;/a&gt;数组声明&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;格式： &lt;code&gt;数据类型 + [] + 数组名称&lt;/code&gt;，例如&lt;code&gt;int[] a&lt;/code&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试" scheme="http://echoguan.coding.me/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="数组" scheme="http://echoguan.coding.me/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>React - 组件的数据 - Note(2)</title>
    <link href="http://echoguan.coding.me/2018/03/19/React%E7%BB%84%E4%BB%B6%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
    <id>http://echoguan.coding.me/2018/03/19/React组件的数据/</id>
    <published>2018-03-19T05:39:40.000Z</published>
    <updated>2018-11-22T02:58:38.301Z</updated>
    
    <content type="html"><![CDATA[<ul><li><code>React组件</code> 的数据分为两种，<code>prop</code> 和<code>state</code>。</li><li>无论prop或者state的改变，都可能引发组件的 <strong>重新渲染</strong>。</li><li><code>prop</code> 是组件的对外接口，<code>state</code> 是组件的内部状态。</li></ul><h4 id="React-的prop"><a href="#React-的prop" class="headerlink" title="React 的prop"></a>React 的prop</h4><ul><li><code>prop</code>( property 的简写) 是从外部传递给组件的数据。</li><li>一个React 组件通过定义自己能够接受的<code>prop</code>就定义了自己得对外公共接口。</li><li>外部世界就是通过<code>prop</code>来和组件对话的。</li></ul><h5 id="1-给-prop-赋值"><a href="#1-给-prop-赋值" class="headerlink" title="1.给 prop 赋值"></a>1.给 prop 赋值</h5><figure class="highlight htmlbars"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">SampleButton</span></span></span></div><div class="line"><span class="xml">  id="sample" borderWidth=&#123;2&#125; onClick=&#123;onButtonClick&#125;</span></div><div class="line"><span class="xml">  style=</span><span class="template-variable">&#123;&#123;color: <span class="string">"red"</span>&#125;&#125;</span><span class="xml"></span></div><div class="line"><span class="xml">/&gt;</span></div></pre></td></tr></table></figure><a id="more"></a><ul><li>上面是一个名为 SampleButton 的组件实例，使用了名字分别为<code>id</code>、<code>borderWidth</code>、<code>onClick</code>和<code>style</code>的<code>prop</code>。</li><li>看起来，<code>prop</code>很像是 HTML 元素的属性，不过：<ul><li>HTML 元素的属性的值都是字符串类型。</li><li>而 React 组件的 prop所支持的类型则非常丰富，除了字符串，可以是任何一种 JavaScript 支持的数据类型。</li><li>borderWidth —— 数字类型</li><li>onClick —— 函数类型</li><li>style —— 是一个包含 color 字段的对象</li></ul></li><li><strong>当 <code>prop</code>的类型不是字符串类型时，在<code>JSX</code>中必须用花括号<code>{}</code>把<code>prop</code>值包住。</strong></li><li><code>style</code>的值有两层花括号，外层的代表<code>JSX</code>的语法，内层的花括号则代表这是一个对象常量。</li><li>React 要求 <code>render</code> 函数只能返回一个元素。</li></ul><h5 id="2-读取-prop-值"><a href="#2-读取-prop-值" class="headerlink" title="2.读取 prop 值"></a>2.读取 prop 值</h5><ul><li>组件内部首先通过构造函数接收传入的<code>prop</code>。</li><li>如果一个组件要定义自己的构造函数，一定要记得在构造函数的第一行通过<code>super(props)</code>调用父类也就是<code>React.Component</code>的构造函数。<ul><li>如果没有调用<code>super(props)</code>，那么组件实例被构造之后，类实例的成员函数就无法通过<code>this.props</code>访问到父组件传递过来的<code>props</code>。</li><li>很明显，给<code>this.props</code>赋值是<code>React.Component</code>构造函数的工作之一。</li></ul></li></ul><h5 id="3-propTypes检查"><a href="#3-propTypes检查" class="headerlink" title="3.propTypes检查"></a>3.<code>propTypes</code>检查</h5><ul><li>React通过<code>propTypes</code>来让组件声明自己的接口规范。<ul><li>这个组件支持哪些<code>prop</code>。</li><li>每个<code>prop</code>应该是什么样的格式。</li></ul></li></ul><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Counter.propTypes = &#123;</div><div class="line">  <span class="attribute">caption</span>: PropTypes<span class="variable">.string</span><span class="variable">.isRequired</span>,</div><div class="line">  initValue: PropTypes<span class="variable">.number</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><ul><li><code>caption</code> 必须为<code>string</code>类型，且是必须要指定的。</li><li><code>initValue</code>必须是<code>number</code>类型，如果没有也没关系。</li><li>如果不符合规范，则会在控制台<code>Console</code>里报<code>Warning</code>，但组件仍旧可以工作。</li><li><code>propTypes</code>虽然能在开发阶段发现代码中的问题，但放在产品环境中就不大合适了。<ul><li>最好的方式是，开发者在代码中定义<code>propTypes</code>，在开发时避免错误。</li><li>但在发布产品时，用一种自动的方式将<code>propTypes</code>去掉，这样部署到产品环境的代码会更优。</li><li>现有的<code>babel-react-optimize</code>就有这个功能，但应确保只在发布产品代码是使用它。</li></ul></li></ul><h4 id="React-的state"><a href="#React-的state" class="headerlink" title="React 的state"></a>React 的state</h4><ul><li><code>state</code> 代表组件的内部状态。</li></ul><h5 id="1-初始化state"><a href="#1-初始化state" class="headerlink" title="1. 初始化state"></a>1. 初始化<code>state</code></h5><ul><li>通常在构造函数结尾处初始化 <code>state</code></li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">constructor</span> <span class="params">(props)</span> <span class="comment">&#123;</span></span></div><div class="line"><span class="function"><span class="comment">  ...</span></span></div><div class="line"><span class="function"><span class="comment"></span></span></div><div class="line"><span class="function"><span class="comment">  this.state = &#123;</span></span></div><div class="line"><span class="function"><span class="comment">    count: props.initValue || 0</span></span></div><div class="line"><span class="function"><span class="comment">  &#125;</span></span></div><div class="line"><span class="function">&#125;</span></div></pre></td></tr></table></figure><ul><li><p>因为<code>initValue</code>是一个可选的<code>props</code>，要考虑到父组件没有指定其值的情况。如果没有的话就使用默认值<code>0</code>。</p><ul><li>不过，让这样的逻辑充斥在构造函数中并不是一件美观的事情，而且容易有遗漏。</li><li>我们可以使用React的<code>defaultProps</code>功能，使代码更易懂。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Counter<span class="selector-class">.defaultProps</span> = &#123;</div><div class="line">  initValue: <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>组建的<code>state</code>必须是一个<code>JavaScript</code>对象。</p></li></ul><h5 id="2-读取和更新state"><a href="#2-读取和更新state" class="headerlink" title="2. 读取和更新state"></a>2. 读取和更新<code>state</code></h5><figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">on</span>ClickIncrementButton () &#123;</div><div class="line">  this.<span class="built_in">set</span>State(&#123;count: this.<span class="keyword">state</span>.count + <span class="number">1</span>&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>值得注意的是，我们改变组件<code>state</code>的值必须要使用<code>this.setState</code>函数，而不能直接去修改<code>this.state</code>。<ul><li>因为，直接修改<code>this.state</code>的值，虽然事实上改变了组建的内部状态，但只是野蛮的修改了<code>state</code>，<strong>却没有驱动组件进行重新渲染</strong>，当然不会在页面上反应出变化。</li><li>而<code>this.setState</code>函数所做的事情，首先是改变<code>this.state</code>的值，<strong>然后驱动组件经历更新过程，重新渲染</strong>。</li></ul></li></ul><h4 id="prop和state的对比"><a href="#prop和state的对比" class="headerlink" title="prop和state的对比"></a>prop和state的对比</h4><ul><li><code>prop</code>用于定义外部接口；<code>state</code>用于记录内部状态。</li><li><code>prop</code>的赋值在外部世界使用组件时；<code>state</code>的赋值在组件内部。</li><li>组件不应该改变<code>prop</code>的值；而<code>state</code>存在的目的就是让组件来改变。</li></ul><ul><li>通过<code>this.setState</code>函数修改state就是改变了组件的状态。</li><li>但是，组件是绝不应该去修改传入的<code>props</code>值。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;code&gt;React组件&lt;/code&gt; 的数据分为两种，&lt;code&gt;prop&lt;/code&gt; 和&lt;code&gt;state&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;无论prop或者state的改变，都可能引发组件的 &lt;strong&gt;重新渲染&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prop&lt;/code&gt; 是组件的对外接口，&lt;code&gt;state&lt;/code&gt; 是组件的内部状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;React-的prop&quot;&gt;&lt;a href=&quot;#React-的prop&quot; class=&quot;headerlink&quot; title=&quot;React 的prop&quot;&gt;&lt;/a&gt;React 的prop&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;prop&lt;/code&gt;( property 的简写) 是从外部传递给组件的数据。&lt;/li&gt;
&lt;li&gt;一个React 组件通过定义自己能够接受的&lt;code&gt;prop&lt;/code&gt;就定义了自己得对外公共接口。&lt;/li&gt;
&lt;li&gt;外部世界就是通过&lt;code&gt;prop&lt;/code&gt;来和组件对话的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;1-给-prop-赋值&quot;&gt;&lt;a href=&quot;#1-给-prop-赋值&quot; class=&quot;headerlink&quot; title=&quot;1.给 prop 赋值&quot;&gt;&lt;/a&gt;1.给 prop 赋值&lt;/h5&gt;&lt;figure class=&quot;highlight htmlbars&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;SampleButton&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;  id=&quot;sample&quot; borderWidth=&amp;#123;2&amp;#125; onClick=&amp;#123;onButtonClick&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;  style=&lt;/span&gt;&lt;span class=&quot;template-variable&quot;&gt;&amp;#123;&amp;#123;color: &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;&amp;#125;&amp;#125;&lt;/span&gt;&lt;span class=&quot;xml&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="笔记" scheme="http://echoguan.coding.me/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="React" scheme="http://echoguan.coding.me/tags/React/"/>
    
      <category term="《深入浅出React和Redux》" scheme="http://echoguan.coding.me/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAReact%E5%92%8CRedux%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Interview - 前端面试题汇总</title>
    <link href="http://echoguan.coding.me/2018/03/14/%E5%89%8D%E7%AB%AFInterview/"/>
    <id>http://echoguan.coding.me/2018/03/14/前端Interview/</id>
    <published>2018-03-14T14:34:58.000Z</published>
    <updated>2018-11-22T02:58:38.314Z</updated>
    
    <content type="html"><![CDATA[<h5 id="比较typeof与instanceof？"><a href="#比较typeof与instanceof？" class="headerlink" title="比较typeof与instanceof？"></a>比较typeof与instanceof？</h5><h5 id="JS原型"><a href="#JS原型" class="headerlink" title="JS原型"></a>JS原型</h5><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><h5 id="JS面向对象"><a href="#JS面向对象" class="headerlink" title="JS面向对象"></a>JS面向对象</h5><h5 id="常见ES6新特性"><a href="#常见ES6新特性" class="headerlink" title="常见ES6新特性"></a>常见ES6新特性</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;比较typeof与instanceof？&quot;&gt;&lt;a href=&quot;#比较typeof与instanceof？&quot; class=&quot;headerlink&quot; title=&quot;比较typeof与instanceof？&quot;&gt;&lt;/a&gt;比较typeof与instanceof？&lt;/h5&gt;&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试" scheme="http://echoguan.coding.me/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="前端" scheme="http://echoguan.coding.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://echoguan.coding.me/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>备忘 - VSCode 使用小技巧 Tips</title>
    <link href="http://echoguan.coding.me/2018/03/07/VSCode-%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7Tips/"/>
    <id>http://echoguan.coding.me/2018/03/07/VSCode-使用小技巧Tips/</id>
    <published>2018-03-07T11:52:38.000Z</published>
    <updated>2018-11-22T02:58:38.306Z</updated>
    
    <content type="html"><![CDATA[<h4 id="快速开始编写html的方法"><a href="#快速开始编写html的方法" class="headerlink" title="快速开始编写html的方法"></a>快速开始编写html的方法</h4><ol><li>首先在第一行输入<code>!</code></li><li>然后将光标移动到<code>!</code>后</li><li>按下<code>tab</code>键</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;快速开始编写html的方法&quot;&gt;&lt;a href=&quot;#快速开始编写html的方法&quot; class=&quot;headerlink&quot; title=&quot;快速开始编写html的方法&quot;&gt;&lt;/a&gt;快速开始编写html的方法&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;首先在第一行输入&lt;code&gt;!&lt;/cod
      
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="VSCode" scheme="http://echoguan.coding.me/tags/VSCode/"/>
    
      <category term="技巧" scheme="http://echoguan.coding.me/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Java - 抽象类和接口的区别，具体使用场景</title>
    <link href="http://echoguan.coding.me/2018/03/06/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/"/>
    <id>http://echoguan.coding.me/2018/03/06/抽象类与接口/</id>
    <published>2018-03-06T15:32:03.000Z</published>
    <updated>2018-11-22T02:58:38.326Z</updated>
    
    <content type="html"><![CDATA[<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><ul><li>包含抽象方法的类称为抽象类。</li><li>但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。</li><li>抽象类里面也可以没有抽象方法。  </li></ul><p>抽象类和普通类的主要有三点区别：<br><a id="more"></a></p><ol><li>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</li><li>因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象。</li><li>如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。</li></ol><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><ul><li>接口中可以含有变量和方法。<ul><li>但是要注意，接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量，用private修饰会报编译错误）。</li><li>而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误）。</li></ul></li><li>接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法。</li></ul><h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h5><ol><li>两者都是抽象的，都不能实例化。</li><li>它们的实现类和子类都必须要实现已经声明的抽象方法。</li></ol><h5 id="不同点-Java-7版本"><a href="#不同点-Java-7版本" class="headerlink" title="不同点(Java 7版本)"></a>不同点(Java 7版本)</h5><ul><li>接口需要实现，一个类可以实现多个接口；抽象类需要继承，而一个类只能继承一个抽象类。</li><li>接口强调的是特定功能（like-a）；抽象类强调所属关系（is-a）。<ul><li>所以，抽象类命名多用名词，接口多用『可XXOO的』这种形容词。</li></ul></li><li>抽象类的变量和方法可以有各种类型的，接口只有public类型（方法：public abstract；成员变量：public static final）。</li><li>抽象类中可以提供成员方法的实现细节；接口只能提供抽象(public abstract)方法。<ul><li>Java 8新增default method，让接口中可以包含方法的实现。</li><li>Java 9中，接口再次增强，可以实现private method和private static method。</li><li>在有了这俩以后，接口和抽象类的区别，只剩下了构造器、成员变量、以及单继承。</li></ul></li><li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法。</li><li>设计层次不同，抽象类是自下而上的设置，在子类中重复出现的工作，抽象到抽象类中；借口是自上而下的，定义行为和规范。</li></ul><h5 id="接口与抽象类应用场景区别"><a href="#接口与抽象类应用场景区别" class="headerlink" title="接口与抽象类应用场景区别"></a>接口与抽象类应用场景区别</h5><p><strong> 根据它们的不同点选择合理的使用场景 </strong></p><ul><li>如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。</li><li>如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。</li><li>如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。</li></ul><blockquote><p>Reference</p><ul><li><a href="http://www.importnew.com/18780.html" target="_blank" rel="noopener">深入理解Java的接口和抽象类</a></li><li><a href="http://www.importnew.com/12399.html" target="_blank" rel="noopener">Java抽象类与接口的区别</a></li><li><a href="https://www.zhihu.com/question/41166418/answer/139494009" target="_blank" rel="noopener">Java 8接口有default method后是不是可以放弃抽象类了？</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;包含抽象方法的类称为抽象类。&lt;/li&gt;
&lt;li&gt;但并不意味着抽象类中只能有抽象方法，它和普通类一样，同样可以拥有成员变量和普通的成员方法。&lt;/li&gt;
&lt;li&gt;抽象类里面也可以没有抽象方法。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;抽象类和普通类的主要有三点区别：&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://echoguan.coding.me/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="面试" scheme="http://echoguan.coding.me/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="抽象类" scheme="http://echoguan.coding.me/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
      <category term="接口" scheme="http://echoguan.coding.me/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
</feed>
